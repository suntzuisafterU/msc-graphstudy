<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>graphstudy: msc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">graphstudy
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">msc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Top-level name-space for pretty much everything in this project.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemsc_1_1test"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc_1_1test.html">test</a></td></tr>
<tr class="memdesc:namespacemsc_1_1test"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name-space for auxiliary unit testing utilities. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemsc_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemsc_1_1benchmark"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc_1_1benchmark.html">benchmark</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__base.html">cli_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base-class for command-line interfaces.  <a href="structmsc_1_1cli__base.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1command__line__interface.html">command_line_interface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic command-line interface.  <a href="classmsc_1_1command__line__interface.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__parameters__interpolation.html">cli_parameters_interpolation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type intended as base class for layout interpolation CLI parameters.  <a href="structmsc_1_1cli__parameters__interpolation.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__parameters__worsening.html">cli_parameters_worsening</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type intended as base class for layout worsening CLI parameters.  <a href="structmsc_1_1cli__parameters__worsening.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__parameters__property.html">cli_parameters_property</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type intended as base class for property computation CLI parameters.  <a href="structmsc_1_1cli__parameters__property.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__parameters__property__local.html">cli_parameters_property_local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type intended as base class for localized property computation CLI parameters.  <a href="structmsc_1_1cli__parameters__property__local.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1cli__parameters__metric.html">cli_parameters_metric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1cuboid.html">cuboid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An axis-aligned <em>N</em>-dimensional cuboid.  <a href="classmsc_1_1cuboid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1data__analyzer.html">data_analyzer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic data analyzer and presenter.  <a href="classmsc_1_1data__analyzer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1file.html">file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An I/O terminal with no associated direction.  <a href="classmsc_1_1file.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1input__file.html">input_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input terminal.  <a href="structmsc_1_1input__file.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1output__file.html">output_file</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output terminal.  <a href="structmsc_1_1output__file.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1histogram.html">histogram</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dense histogram.  <a href="classmsc_1_1histogram.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1unsupported__format.html">unsupported_format</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that indicates that an I/O operation failed because the requested file format is not supported.  <a href="structmsc_1_1unsupported__format.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1degenerated__layout.html">degenerated_layout</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception that indicates that an I/O operation failed because the input file had graph but no layout data.  <a href="structmsc_1_1degenerated__layout.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__null.html">json_null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <code>null</code> value.  <a href="structmsc_1_1json__null.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__text.html">json_text</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a text value.  <a href="structmsc_1_1json__text.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__bool.html">json_bool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a logical value.  <a href="structmsc_1_1json__bool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__real.html">json_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a real value.  <a href="structmsc_1_1json__real.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__size.html">json_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a <code>size_t</code> value.  <a href="structmsc_1_1json__size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__diff.html">json_diff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a <code>ptrdiff_t</code> value.  <a href="structmsc_1_1json__diff.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__array.html">json_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered array of zero or more arbitrary JSON values.  <a href="structmsc_1_1json__array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1json__object.html">json_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unordered associative array of zero or more arbitrary JSON values.  <a href="structmsc_1_1json__object.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1tautology__node__pair__predicate.html">tautology_node_pair_predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A predicate that filters all pairs of nodes.  <a href="structmsc_1_1tautology__node__pair__predicate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1identity__node__pair__projection.html">identity_node_pair_projection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An identity projection.  <a href="structmsc_1_1identity__node__pair__projection.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1node__pair__iterator.html">node_pair_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic iterator that iterates over a projection of filtered pairs of nodes in a layout.  <a href="classmsc_1_1node__pair__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1threshold__node__pair__predicate.html">threshold_node_pair_predicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A meta-predicate that filters pairs of nodes based on a threshold and a pre-computed table.  <a href="classmsc_1_1threshold__node__pair__predicate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1point.html">point</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1point_3_01_t_00_012_01_4.html">point&lt; T, 2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1point_3_01_t_00_013_01_4.html">point&lt; T, 3 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1point__order.html">point_order</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1node__distance.html">node_distance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection of node pairs to their euclidian distance.  <a href="structmsc_1_1node__distance.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1global__pairwise__distances.html">global_pairwise_distances</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the range of all pairwise Euclidian distances in the layout.  <a href="classmsc_1_1global__pairwise__distances.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1local__pairwise__distances.html">local_pairwise_distances</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the range of all pairwise Euclidian distances between nodes (u, v) where the shortest path between u and v does not exceed a given limit in the layout.  <a href="classmsc_1_1local__pairwise__distances.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1gaussian__kernel.html">gaussian_kernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian filter for a range of values.  <a href="classmsc_1_1gaussian__kernel.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregation of various elementary stochastic properties or a range <em>x</em><sub>1</sub>,  <em>x</em><sub><em>n</em></sub> of real values.  <a href="structmsc_1_1stochastic__summary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1gaussian.html">gaussian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object implementing a Gaussian function.  <a href="structmsc_1_1gaussian.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result from fitting a quadratic polynomial and finding its extremal point.  <a href="structmsc_1_1parabola__result.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1node__stress.html">node_stress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection of node pairs to the their term contributed to the sum in stress computation.  <a href="structmsc_1_1node__stress.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1pairwise__stress.html">pairwise_stress</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the range of terms contributing to the stress.  <a href="classmsc_1_1pairwise__stress.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsc_1_1node__tension.html">node_tension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projection of node pairs to the quotient of their Euclidian distance in the layout and graph-theoretical distance.  <a href="structmsc_1_1node__tension.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmsc_1_1pairwise__tension.html">pairwise_tension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presents the range of quotients of Euclidian distance in the layout and graph-theoretical distance between connected nodes.  <a href="classmsc_1_1pairwise__tension.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4a63a9d3b73b9aa1106194c6d9f5610b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a63a9d3b73b9aa1106194c6d9f5610b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a4a63a9d3b73b9aa1106194c6d9f5610b">planar_line</a> = std::pair&lt; <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;, <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;&gt;</td></tr>
<tr class="memdesc:a4a63a9d3b73b9aa1106194c6d9f5610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Planar line represented by its start and end points.  <a href="#a4a63a9d3b73b9aa1106194c6d9f5610b">More...</a><br/></td></tr>
<tr class="separator:a4a63a9d3b73b9aa1106194c6d9f5610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd98b85959d8bf574c6a2c4315baf6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a> = std::variant&lt; <a class="el" href="structmsc_1_1json__null.html">json_null</a>, <a class="el" href="structmsc_1_1json__text.html">json_text</a>, <a class="el" href="structmsc_1_1json__bool.html">json_bool</a>, <a class="el" href="structmsc_1_1json__real.html">json_real</a>, <a class="el" href="structmsc_1_1json__size.html">json_size</a>, <a class="el" href="structmsc_1_1json__diff.html">json_diff</a>, <a class="el" href="structmsc_1_1json__array.html">json_array</a>, <a class="el" href="structmsc_1_1json__object.html">json_object</a> &gt;</td></tr>
<tr class="memdesc:a5dd98b85959d8bf574c6a2c4315baf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic type holding any JSON value (including <code>null</code>).  <a href="#a5dd98b85959d8bf574c6a2c4315baf6d">More...</a><br/></td></tr>
<tr class="separator:a5dd98b85959d8bf574c6a2c4315baf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8194fd1e1916ad4a3dee4298bd3f912f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8194fd1e1916ad4a3dee4298bd3f912f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8194fd1e1916ad4a3dee4298bd3f912f">ogdf_node_array_1d</a> = ogdf::NodeArray&lt; T &gt;</td></tr>
<tr class="memdesc:a8194fd1e1916ad4a3dee4298bd3f912f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient type alias for a node property.  <a href="#a8194fd1e1916ad4a3dee4298bd3f912f">More...</a><br/></td></tr>
<tr class="separator:a8194fd1e1916ad4a3dee4298bd3f912f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a491ef1c186f808bbf89dec87e43f26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a491ef1c186f808bbf89dec87e43f26"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9a491ef1c186f808bbf89dec87e43f26">ogdf_node_array_2d</a> = ogdf::NodeArray&lt; ogdf::NodeArray&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:a9a491ef1c186f808bbf89dec87e43f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient type alias for a pairwise node property.  <a href="#a9a491ef1c186f808bbf89dec87e43f26">More...</a><br/></td></tr>
<tr class="separator:a9a491ef1c186f808bbf89dec87e43f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453b2e80f3f642cd10f6766efc95edaa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a453b2e80f3f642cd10f6766efc95edaa">node_pair</a> = std::pair&lt; <a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a>, <a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a> &gt;</td></tr>
<tr class="memdesc:a453b2e80f3f642cd10f6766efc95edaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient type alias for a pair of node pointers.  <a href="#a453b2e80f3f642cd10f6766efc95edaa">More...</a><br/></td></tr>
<tr class="separator:a453b2e80f3f642cd10f6766efc95edaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7642ca88d0f3d1b6a8914ece4c0681e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">point2d</a> = <a class="el" href="structmsc_1_1point.html">point</a>&lt; double, 2 &gt;</td></tr>
<tr class="separator:ab7642ca88d0f3d1b6a8914ece4c0681e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92096d34308c14b65f1ef6c7c1f47970"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a92096d34308c14b65f1ef6c7c1f47970">point3d</a> = <a class="el" href="structmsc_1_1point.html">point</a>&lt; double, 3 &gt;</td></tr>
<tr class="separator:a92096d34308c14b65f1ef6c7c1f47970"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a196b5b50d942eacd26d97544a70ff3ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3ca">stress_modi</a> { <a class="el" href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3caacec315e3d0975e5cc2811d5d8725f149">stress_modi::fixed</a>, 
<a class="el" href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3caa05347f66d710a82340c847fa8c9715bc">stress_modi::fit_nodesep</a>, 
<a class="el" href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3caa57333065c549c0468a640e39c0beee65">stress_modi::fit_scale</a>
 }</td></tr>
<tr class="memdesc:a196b5b50d942eacd26d97544a70ff3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration type that is used in the CLI.  <a href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3ca">More...</a><br/></td></tr>
<tr class="separator:a196b5b50d942eacd26d97544a70ff3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a867f812a195890b25dc49b0c14c9b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a> { <br/>
&#160;&#160;<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9bad833560a6ffadaad4d5e2394c9423c0d">algorithms::davidson_harel</a>, 
<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9ba390f9159ed37c3e8cd6037428d12675b">algorithms::fmmm</a>, 
<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9bafd82954f9da15c655bee87e77a9cb693">algorithms::pivot_mds</a>, 
<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9ba076e42393fe86659e9e81c9d6c62b048">algorithms::spring_embedder_kk</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9bae10a36f1a5231e597daf8f42dc1ab55a">algorithms::stress</a>
<br/>
 }</td></tr>
<tr class="memdesc:a93a867f812a195890b25dc49b0c14c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common layouting algorithms.  <a href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">More...</a><br/></td></tr>
<tr class="separator:a93a867f812a195890b25dc49b0c14c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5396b55ae4ea5a0cf2e7add71dca29ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a> { <a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29eda86e705c00d780fb4de3f94c67b2d7156">binnings::fixed_count</a>, 
<a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29eda792851d0725ebe3fa785587003647fe9">binnings::fixed_width</a>, 
<a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29edab1d6c4aa2c3a72bb602d19031a759a86">binnings::scott_normal_reference</a>
 }</td></tr>
<tr class="memdesc:a5396b55ae4ea5a0cf2e7add71dca29ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Histogram binning strategies.  <a href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">More...</a><br/></td></tr>
<tr class="separator:a5396b55ae4ea5a0cf2e7add71dca29ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af083baa2f5eeb44f148fd49aa50b2caf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a> { <a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa2bd9c0ed00116be1258e0cc66617d7c8">compressions::automatic</a>, 
<a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa03ce1ba314f367fdd09887fc8f60578b">compressions::bzip2</a>, 
<a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa749cadba7b2ed8d4a2aaa91a9cb1896c">compressions::gzip</a>, 
<a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa334c4a4c42fdb79d7ebc3e73b517e6f8">compressions::none</a>
 }</td></tr>
<tr class="memdesc:af083baa2f5eeb44f148fd49aa50b2caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data compression stratagies.  <a href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">More...</a><br/></td></tr>
<tr class="separator:af083baa2f5eeb44f148fd49aa50b2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26ed6099a182e487884926c1a32e4f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a> { <a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0afea087517c26fadd409bd4b9dc642555">distributions::normal</a>, 
<a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0aa489ffed938ef1b9e86889bc413501ee">distributions::uniform</a>
 }</td></tr>
<tr class="memdesc:ae26ed6099a182e487884926c1a32e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Real random distributions.  <a href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">More...</a><br/></td></tr>
<tr class="separator:ae26ed6099a182e487884926c1a32e4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45abf669ad17a61f470330d16a9cbcb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> { <br/>
&#160;&#160;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba1d28d258250876fb7dde22a17436ef9c">fileformats::bench</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba3d0e38abf71c7e0333d0a02b0ab788c5">fileformats::chaco</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba01a120c756b1f6cf4f08e0fca0cfa6fe">fileformats::dl</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba95d82d6d9634b7fa4150a62669f29963">fileformats::dmf</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba69eb76c88557a8211cbfc9beda5fc062">fileformats::dot</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbae00eb494cdde999c956da60f5183c69b">fileformats::gd_challenge</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba44fdb916a558ef6739cfa6378de4995a">fileformats::gdf</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbad3828e428256f735a669a4a8a5624ca0">fileformats::gexf</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba4827b0d87596b184031d769793484066">fileformats::gml</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbae0a07cd7e15ec78299781c74556967cd">fileformats::graph6</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbaba9fdc484f1b426d287cc20e9a8cb3dd">fileformats::graphml</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba68e3d3ca71bae332832b42bb38df7503">fileformats::leda</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba98edc8fd111d10b528b4f84d5968db03">fileformats::matrix_market</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbabf688cefd04199b5dff3abe33ceafb28">fileformats::pla</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba006b3a2ef99493587eb654bee633b1e4">fileformats::pm_diss_graph</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba60d99e58d66a5e0f4f89ec3ddd1d9a80">fileformats::rome</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbacfce9735de7c3873a55331a4e74b70fc">fileformats::rudy</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcba1514ef4c38ef3b21bf970755926aadde">fileformats::stp</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbaf666ad4dc5d95bac7f35964e7d56e41e">fileformats::tlp</a>, 
<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcbaf5bf82d97a89bd886096bec297de50ef">fileformats::ygraph</a>
<br/>
 }</td></tr>
<tr class="memdesc:ad45abf669ad17a61f470330d16a9cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graph (and layout) file formats.  <a href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">More...</a><br/></td></tr>
<tr class="separator:ad45abf669ad17a61f470330d16a9cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196c75041f232c8f8c22d81fd90b8274"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a> { <a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274a2f3e3aba4608b6c748b182f722c8f6f0">kernels::boxed</a>, 
<a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274a304e2a3b544f6b9f267a151e1bcee487">kernels::gaussian</a>, 
<a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274abdd166af3a63f7be696dd17a218a6ffb">kernels::raw</a>
 }</td></tr>
<tr class="memdesc:a196c75041f232c8f8c22d81fd90b8274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data aggregation and presentation strategies.  <a href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">More...</a><br/></td></tr>
<tr class="separator:a196c75041f232c8f8c22d81fd90b8274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a30e3eb0cf1bdd3810114605f47475"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a> { <a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475a21a0862152ed5785891fbdbd42a5062a">projections::isometric</a>, 
<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475a1ee509d64a5d1462e497b9f5ed0c73cb">projections::ortho_front</a>, 
<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475abd74f9aa9b8093fee262f2b2a9d2f26b">projections::ortho_side</a>, 
<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475a2c3403610f89b5948c4fc62d04549422">projections::ortho_top</a>
 }</td></tr>
<tr class="memdesc:aa7a30e3eb0cf1bdd3810114605f47475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Graphical projection types.  <a href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">More...</a><br/></td></tr>
<tr class="separator:aa7a30e3eb0cf1bdd3810114605f47475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4f85e669d8d8947ab2fafa95dd6598"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a> { <a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598ada3f6396c032b006442940855c25dfd8">terminals::descriptor</a>, 
<a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598a8c7dd922ad47494fc02c388e12c00eac">terminals::file</a>, 
<a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598a37a6259cc0c1dae299a7866489dff0bd">terminals::null</a>, 
<a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598a4435f0f89633053c96204ebf23d6ea4e">terminals::stdio</a>
 }</td></tr>
<tr class="memdesc:a9e4f85e669d8d8947ab2fafa95dd6598"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O terminal types.  <a href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">More...</a><br/></td></tr>
<tr class="separator:a9e4f85e669d8d8947ab2fafa95dd6598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2016583431e89758955af6974010aa20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a> { <a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1">treatments::exception</a>, 
<a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a567bc1d268f135496de3d5b946b691f3">treatments::ignore</a>, 
<a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a9dde360102c103867bd2f45872f1129c">treatments::replace</a>
 }</td></tr>
<tr class="memdesc:a2016583431e89758955af6974010aa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategies for handling arithmetically undefined results.  <a href="namespacemsc.html#a2016583431e89758955af6974010aa20">More...</a><br/></td></tr>
<tr class="separator:a2016583431e89758955af6974010aa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b1c3f2ee5b986fd5b89decc81f45939"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0b1c3f2ee5b986fd5b89decc81f45939">get_all_angles_between_adjacent_incident_edges</a> (const ogdf::GraphAttributes &amp;attrs, <a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a> treatment=<a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1">treatments::exception</a>)</td></tr>
<tr class="memdesc:a0b1c3f2ee5b986fd5b89decc81f45939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all angles between adjacent incident edges.  <a href="#a0b1c3f2ee5b986fd5b89decc81f45939">More...</a><br/></td></tr>
<tr class="separator:a0b1c3f2ee5b986fd5b89decc81f45939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68ee3f8090280fc7a62065b34cb8cd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab68ee3f8090280fc7a62065b34cb8cd6">guess_terminal_width</a> (int fallback=80) noexcept</td></tr>
<tr class="memdesc:ab68ee3f8090280fc7a62065b34cb8cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guesses the width of the output terminal.  <a href="#ab68ee3f8090280fc7a62065b34cb8cd6">More...</a><br/></td></tr>
<tr class="separator:ab68ee3f8090280fc7a62065b34cb8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111ece927b75ddfc23e8c95e75cb5cc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a111ece927b75ddfc23e8c95e75cb5cc6">check_stdio</a> (std::istream &amp;input, std::ostream &amp;output)</td></tr>
<tr class="memdesc:a111ece927b75ddfc23e8c95e75cb5cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether standard input or output are in an error state.  <a href="#a111ece927b75ddfc23e8c95e75cb5cc6">More...</a><br/></td></tr>
<tr class="separator:a111ece927b75ddfc23e8c95e75cb5cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77afadb2a5ac037be127482c79b55954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a77afadb2a5ac037be127482c79b55954">check_stdio</a> (std::istream &amp;input, std::ostream &amp;output, std::string &amp;message) noexcept</td></tr>
<tr class="memdesc:a77afadb2a5ac037be127482c79b55954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether standard input or output are in an error state.  <a href="#a77afadb2a5ac037be127482c79b55954">More...</a><br/></td></tr>
<tr class="separator:a77afadb2a5ac037be127482c79b55954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ce49a25a232580ff6f3c23676dc63"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a352ce49a25a232580ff6f3c23676dc63">helptext_file_name_expansion</a> ()</td></tr>
<tr class="memdesc:a352ce49a25a232580ff6f3c23676dc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a generic message that informs the user about the expansion of <code>%</code> characters in file names.  <a href="#a352ce49a25a232580ff6f3c23676dc63">More...</a><br/></td></tr>
<tr class="separator:a352ce49a25a232580ff6f3c23676dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dad6fa2e1e264b66bc570b2b2ad3aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1output__file.html">output_file</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa1dad6fa2e1e264b66bc570b2b2ad3aa">expand_filename</a> (const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;pattern, std::size_t iteration)</td></tr>
<tr class="memdesc:aa1dad6fa2e1e264b66bc570b2b2ad3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a file name by replacing each <code>%</code> in <code>pattern.filename()</code> by a string representation of <code>iteration</code>.  <a href="#aa1dad6fa2e1e264b66bc570b2b2ad3aa">More...</a><br/></td></tr>
<tr class="separator:aa1dad6fa2e1e264b66bc570b2b2ad3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce81081f8150e86ca72e6eacd0002f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1output__file.html">output_file</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#afce81081f8150e86ca72e6eacd0002f3">expand_filename</a> (const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;pattern, std::size_t major, std::size_t minor)</td></tr>
<tr class="memdesc:afce81081f8150e86ca72e6eacd0002f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a file name by replacing the first and second <code>%</code> in <code>pattern.filename()</code> by a string representation of <code>major</code> and <code>minor</code> respectively.  <a href="#afce81081f8150e86ca72e6eacd0002f3">More...</a><br/></td></tr>
<tr class="separator:afce81081f8150e86ca72e6eacd0002f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cd9702266c76722a07ce54d61021e3"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename CuboidT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename PointT  = typename CuboidT::point_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value&gt; </td></tr>
<tr class="memitem:a20cd9702266c76722a07ce54d61021e3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr<br class="typebreak"/>
&lt; ogdf::Graph &gt;<br class="typebreak"/>
, std::unique_ptr<br class="typebreak"/>
&lt; ogdf::GraphAttributes &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a20cd9702266c76722a07ce54d61021e3">convert_and_project</a> (const FwdIterT first, const FwdIterT last)</td></tr>
<tr class="memdesc:a20cd9702266c76722a07ce54d61021e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function was considered useful at one point but is undocumented, untested and unused at the moment.  <a href="#a20cd9702266c76722a07ce54d61021e3">More...</a><br/></td></tr>
<tr class="separator:a20cd9702266c76722a07ce54d61021e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4155dfdaf0b13e32a8d32903cbcb2248"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, <br class="typebreak"/>
double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a4155dfdaf0b13e32a8d32903cbcb2248">initialize_entropies</a> ()</td></tr>
<tr class="memdesc:a4155dfdaf0b13e32a8d32903cbcb2248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an object that is ready to use as collector for entropy data.  <a href="#a4155dfdaf0b13e32a8d32903cbcb2248">More...</a><br/></td></tr>
<tr class="separator:a4155dfdaf0b13e32a8d32903cbcb2248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ec8640424a697ab771e2971b62f6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a12ec8640424a697ab771e2971b62f6d3">append_entropy</a> (std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;entropies, const <a class="el" href="structmsc_1_1json__object.html">json_object</a> &amp;info, std::string_view keyname, std::string_view valname=&quot;entropy&quot;)</td></tr>
<tr class="memdesc:a12ec8640424a697ab771e2971b62f6d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends the entropy of an analysis.  <a href="#a12ec8640424a697ab771e2971b62f6d3">More...</a><br/></td></tr>
<tr class="separator:a12ec8640424a697ab771e2971b62f6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9449e0bd58945761e8d4a097b645a0e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9449e0bd58945761e8d4a097b645a0e9">assign_entropy_regression</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;entropies, <a class="el" href="structmsc_1_1json__object.html">json_object</a> &amp;info)</td></tr>
<tr class="memdesc:a9449e0bd58945761e8d4a097b645a0e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a linear regression over the data held in <code>entropies</code> and assigns the result as <code>entropy-intercept</code> and <code>entropy-slope</code> to <code>info</code>.  <a href="#a9449e0bd58945761e8d4a097b645a0e9">More...</a><br/></td></tr>
<tr class="separator:a9449e0bd58945761e8d4a097b645a0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837ff533f6a2a40ac20b5af9c6e382f"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a3837ff533f6a2a40ac20b5af9c6e382f">find_edge_crossings</a> (const ogdf::GraphAttributes &amp;attrs) -&gt; std::vector&lt; std::tuple&lt; <a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">point2d</a>, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a>, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a> &gt;&gt;</td></tr>
<tr class="memdesc:a3837ff533f6a2a40ac20b5af9c6e382f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the coordinates of all (real) edge crossings (between non-adjacent edges) in a layout.  <a href="#a3837ff533f6a2a40ac20b5af9c6e382f">More...</a><br/></td></tr>
<tr class="separator:a3837ff533f6a2a40ac20b5af9c6e382f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc29e0942012bbf9887ad83888ebb109"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#adc29e0942012bbf9887ad83888ebb109">get_crossing_angle</a> (const ogdf::GraphAttributes &amp;attrs, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a> e1, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a> e2) -&gt; double</td></tr>
<tr class="memdesc:adc29e0942012bbf9887ad83888ebb109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the crossing angle between edges <code>e</code> and <code>e2</code> in layout <code>attrs</code>.  <a href="#adc29e0942012bbf9887ad83888ebb109">More...</a><br/></td></tr>
<tr class="separator:adc29e0942012bbf9887ad83888ebb109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d30898c88b8f84fa3ab7171c6ecade"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56d30898c88b8f84fa3ab7171c6ecade"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a56d30898c88b8f84fa3ab7171c6ecade">check_intersect</a> (<a class="el" href="namespacemsc.html#a4a63a9d3b73b9aa1106194c6d9f5610b">planar_line</a>&lt; T &gt; l1, <a class="el" href="namespacemsc.html#a4a63a9d3b73b9aa1106194c6d9f5610b">planar_line</a>&lt; T &gt; l2) noexcept-&gt; std::optional&lt; <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;&gt;</td></tr>
<tr class="memdesc:a56d30898c88b8f84fa3ab7171c6ecade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines wheter two planar lines intersect each other.  <a href="#a56d30898c88b8f84fa3ab7171c6ecade">More...</a><br/></td></tr>
<tr class="separator:a56d30898c88b8f84fa3ab7171c6ecade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d3489c0c5415591e1e1092a8c8ad27"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a90d3489c0c5415591e1e1092a8c8ad27">get_all_edge_lengths</a> (const ogdf::GraphAttributes &amp;attrs)</td></tr>
<tr class="memdesc:a90d3489c0c5415591e1e1092a8c8ad27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all edge lengths.  <a href="#a90d3489c0c5415591e1e1092a8c8ad27">More...</a><br/></td></tr>
<tr class="separator:a90d3489c0c5415591e1e1092a8c8ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d52b354738f4beb6d29b372710031c"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a>, 5 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a27d52b354738f4beb6d29b372710031c">all_algorithms</a> () noexcept</td></tr>
<tr class="memdesc:a27d52b354738f4beb6d29b372710031c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a27d52b354738f4beb6d29b372710031c">More...</a><br/></td></tr>
<tr class="separator:a27d52b354738f4beb6d29b372710031c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed835959c86eb037e762c3ff06655e6"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a> (<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a> item)</td></tr>
<tr class="memdesc:a0ed835959c86eb037e762c3ff06655e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a0ed835959c86eb037e762c3ff06655e6">More...</a><br/></td></tr>
<tr class="separator:a0ed835959c86eb037e762c3ff06655e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9188d09cfe45cee611d916401b739689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9188d09cfe45cee611d916401b739689">value_of_algorithms</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a9188d09cfe45cee611d916401b739689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a9188d09cfe45cee611d916401b739689">More...</a><br/></td></tr>
<tr class="separator:a9188d09cfe45cee611d916401b739689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb392dc67542ba306260e1524afa20e"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a>, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a3fb392dc67542ba306260e1524afa20e">all_binnings</a> () noexcept</td></tr>
<tr class="memdesc:a3fb392dc67542ba306260e1524afa20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a3fb392dc67542ba306260e1524afa20e">More...</a><br/></td></tr>
<tr class="separator:a3fb392dc67542ba306260e1524afa20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c7a900d18cacd360f211a24e50b77f"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a04c7a900d18cacd360f211a24e50b77f">name</a> (<a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a> item)</td></tr>
<tr class="memdesc:a04c7a900d18cacd360f211a24e50b77f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a04c7a900d18cacd360f211a24e50b77f">More...</a><br/></td></tr>
<tr class="separator:a04c7a900d18cacd360f211a24e50b77f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdc4553a9880ed4206ce10b23466c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1cdc4553a9880ed4206ce10b23466c11">value_of_binnings</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a1cdc4553a9880ed4206ce10b23466c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a1cdc4553a9880ed4206ce10b23466c11">More...</a><br/></td></tr>
<tr class="separator:a1cdc4553a9880ed4206ce10b23466c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b6f20bcb66876e063d9d769b6ad89b"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a>, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a67b6f20bcb66876e063d9d769b6ad89b">all_compressions</a> () noexcept</td></tr>
<tr class="memdesc:a67b6f20bcb66876e063d9d769b6ad89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a67b6f20bcb66876e063d9d769b6ad89b">More...</a><br/></td></tr>
<tr class="separator:a67b6f20bcb66876e063d9d769b6ad89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0281a426c71a4921711b55f3b57326"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0a0281a426c71a4921711b55f3b57326">name</a> (<a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a> item)</td></tr>
<tr class="memdesc:a0a0281a426c71a4921711b55f3b57326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a0a0281a426c71a4921711b55f3b57326">More...</a><br/></td></tr>
<tr class="separator:a0a0281a426c71a4921711b55f3b57326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9020ff3e68668c2a15210ab61510d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0e9020ff3e68668c2a15210ab61510d8">value_of_compressions</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a0e9020ff3e68668c2a15210ab61510d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a0e9020ff3e68668c2a15210ab61510d8">More...</a><br/></td></tr>
<tr class="separator:a0e9020ff3e68668c2a15210ab61510d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8bf95ccae2c40d79d81c7893dab028"><td class="memItemLeft" align="right" valign="top">const std::array<br class="typebreak"/>
&lt; <a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a>, 2 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#abb8bf95ccae2c40d79d81c7893dab028">all_distributions</a> () noexcept</td></tr>
<tr class="memdesc:abb8bf95ccae2c40d79d81c7893dab028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#abb8bf95ccae2c40d79d81c7893dab028">More...</a><br/></td></tr>
<tr class="separator:abb8bf95ccae2c40d79d81c7893dab028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ed93ac534cdf71778774130d8e40ff"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a78ed93ac534cdf71778774130d8e40ff">name</a> (<a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a> item)</td></tr>
<tr class="memdesc:a78ed93ac534cdf71778774130d8e40ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a78ed93ac534cdf71778774130d8e40ff">More...</a><br/></td></tr>
<tr class="separator:a78ed93ac534cdf71778774130d8e40ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1795ee21966de46cf71e572d5a457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#af2b1795ee21966de46cf71e572d5a457">value_of_distributions</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:af2b1795ee21966de46cf71e572d5a457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#af2b1795ee21966de46cf71e572d5a457">More...</a><br/></td></tr>
<tr class="separator:af2b1795ee21966de46cf71e572d5a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72357f313ae8745d242cf803ffe5df0d"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a>, 20 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a72357f313ae8745d242cf803ffe5df0d">all_fileformats</a> () noexcept</td></tr>
<tr class="memdesc:a72357f313ae8745d242cf803ffe5df0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a72357f313ae8745d242cf803ffe5df0d">More...</a><br/></td></tr>
<tr class="separator:a72357f313ae8745d242cf803ffe5df0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f237c430b107b903b29246bc17bbb79"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1f237c430b107b903b29246bc17bbb79">name</a> (<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> item)</td></tr>
<tr class="memdesc:a1f237c430b107b903b29246bc17bbb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a1f237c430b107b903b29246bc17bbb79">More...</a><br/></td></tr>
<tr class="separator:a1f237c430b107b903b29246bc17bbb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ca3318fd8c30d7c78f9bc462f732e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a38ca3318fd8c30d7c78f9bc462f732e3">value_of_fileformats</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a38ca3318fd8c30d7c78f9bc462f732e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a38ca3318fd8c30d7c78f9bc462f732e3">More...</a><br/></td></tr>
<tr class="separator:a38ca3318fd8c30d7c78f9bc462f732e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84400a106d7d2053e2949f57ce3b84b3"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a>, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a84400a106d7d2053e2949f57ce3b84b3">all_kernels</a> () noexcept</td></tr>
<tr class="memdesc:a84400a106d7d2053e2949f57ce3b84b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a84400a106d7d2053e2949f57ce3b84b3">More...</a><br/></td></tr>
<tr class="separator:a84400a106d7d2053e2949f57ce3b84b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b5bacbf3b7b252e6207494b4cb4bd0"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab9b5bacbf3b7b252e6207494b4cb4bd0">name</a> (<a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a> item)</td></tr>
<tr class="memdesc:ab9b5bacbf3b7b252e6207494b4cb4bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#ab9b5bacbf3b7b252e6207494b4cb4bd0">More...</a><br/></td></tr>
<tr class="separator:ab9b5bacbf3b7b252e6207494b4cb4bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efc23f4e42fed42d0037a8b17e16cd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a6efc23f4e42fed42d0037a8b17e16cd1">value_of_kernels</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a6efc23f4e42fed42d0037a8b17e16cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a6efc23f4e42fed42d0037a8b17e16cd1">More...</a><br/></td></tr>
<tr class="separator:a6efc23f4e42fed42d0037a8b17e16cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab409b5c3ca7507c789550e4389f9d741"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a>, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab409b5c3ca7507c789550e4389f9d741">all_projections</a> () noexcept</td></tr>
<tr class="memdesc:ab409b5c3ca7507c789550e4389f9d741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#ab409b5c3ca7507c789550e4389f9d741">More...</a><br/></td></tr>
<tr class="separator:ab409b5c3ca7507c789550e4389f9d741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2bfc9b325611412f30ddd0efd12c90"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5b2bfc9b325611412f30ddd0efd12c90">name</a> (<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a> item)</td></tr>
<tr class="memdesc:a5b2bfc9b325611412f30ddd0efd12c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a5b2bfc9b325611412f30ddd0efd12c90">More...</a><br/></td></tr>
<tr class="separator:a5b2bfc9b325611412f30ddd0efd12c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad458616967f97fb27dddda6bc2c2be9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ad458616967f97fb27dddda6bc2c2be9d">value_of_projections</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:ad458616967f97fb27dddda6bc2c2be9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#ad458616967f97fb27dddda6bc2c2be9d">More...</a><br/></td></tr>
<tr class="separator:ad458616967f97fb27dddda6bc2c2be9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc40feb28d95d981cc79f3728a440b25"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a>, 4 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#abc40feb28d95d981cc79f3728a440b25">all_terminals</a> () noexcept</td></tr>
<tr class="memdesc:abc40feb28d95d981cc79f3728a440b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#abc40feb28d95d981cc79f3728a440b25">More...</a><br/></td></tr>
<tr class="separator:abc40feb28d95d981cc79f3728a440b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a98f8a24674b0a668f6672fc3d37c05"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1a98f8a24674b0a668f6672fc3d37c05">name</a> (<a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a> item)</td></tr>
<tr class="memdesc:a1a98f8a24674b0a668f6672fc3d37c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a1a98f8a24674b0a668f6672fc3d37c05">More...</a><br/></td></tr>
<tr class="separator:a1a98f8a24674b0a668f6672fc3d37c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475788cc4928371f0dd3e19b255ce761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a475788cc4928371f0dd3e19b255ce761">value_of_terminals</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a475788cc4928371f0dd3e19b255ce761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a475788cc4928371f0dd3e19b255ce761">More...</a><br/></td></tr>
<tr class="separator:a475788cc4928371f0dd3e19b255ce761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5509cd4248ba252c6dbdd8eb10d72aed"><td class="memItemLeft" align="right" valign="top">const std::array&lt; <a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a>, 3 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5509cd4248ba252c6dbdd8eb10d72aed">all_treatments</a> () noexcept</td></tr>
<tr class="memdesc:a5509cd4248ba252c6dbdd8eb10d72aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reference to a statically allocated array of all declared enumerators.  <a href="#a5509cd4248ba252c6dbdd8eb10d72aed">More...</a><br/></td></tr>
<tr class="separator:a5509cd4248ba252c6dbdd8eb10d72aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af4048c07ba9f49a3e582cbf823ed8c"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5af4048c07ba9f49a3e582cbf823ed8c">name</a> (<a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a> item)</td></tr>
<tr class="memdesc:a5af4048c07ba9f49a3e582cbf823ed8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the canonical name of an enumerator.  <a href="#a5af4048c07ba9f49a3e582cbf823ed8c">More...</a><br/></td></tr>
<tr class="separator:a5af4048c07ba9f49a3e582cbf823ed8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ee6482b19a96c5b26bb6e4a5053ae8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a87ee6482b19a96c5b26bb6e4a5053ae8">value_of_treatments</a> (std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a87ee6482b19a96c5b26bb6e4a5053ae8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the enumerator for a name.  <a href="#a87ee6482b19a96c5b26bb6e4a5053ae8">More...</a><br/></td></tr>
<tr class="separator:a87ee6482b19a96c5b26bb6e4a5053ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b379b7f3077336fef08bf586e9e279e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8b379b7f3077336fef08bf586e9e279e">operator==</a> (const <a class="el" href="classmsc_1_1file.html">file</a> &amp;lhs, const <a class="el" href="classmsc_1_1file.html">file</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a8b379b7f3077336fef08bf586e9e279e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code>file</code>s for equality.  <a href="#a8b379b7f3077336fef08bf586e9e279e">More...</a><br/></td></tr>
<tr class="separator:a8b379b7f3077336fef08bf586e9e279e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1067d6c4cdeef219fa9ab99ab49ba94a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1067d6c4cdeef219fa9ab99ab49ba94a">operator!=</a> (const <a class="el" href="classmsc_1_1file.html">file</a> &amp;lhs, const <a class="el" href="classmsc_1_1file.html">file</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a1067d6c4cdeef219fa9ab99ab49ba94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <code>file</code>s for inequality.  <a href="#a1067d6c4cdeef219fa9ab99ab49ba94a">More...</a><br/></td></tr>
<tr class="separator:a1067d6c4cdeef219fa9ab99ab49ba94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f564a7bd01e10abef320189e02e7fd2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a6f564a7bd01e10abef320189e02e7fd2">graph_fingerprint</a> (const ogdf::Graph &amp;graph)</td></tr>
<tr class="memdesc:a6f564a7bd01e10abef320189e02e7fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fixed-length string that only depends on the given graph and is unlikely to collide with the ID returned for any other graph.  <a href="#a6f564a7bd01e10abef320189e02e7fd2">More...</a><br/></td></tr>
<tr class="separator:a6f564a7bd01e10abef320189e02e7fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3cfe66d267275c3278ca0884acbcf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aad3cfe66d267275c3278ca0884acbcf4">layout_fingerprint</a> (const ogdf::GraphAttributes &amp;attrs)</td></tr>
<tr class="memdesc:aad3cfe66d267275c3278ca0884acbcf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fixed-length string that only depends on the given layout and is unlikely to collide with the ID returned for any other layout.  <a href="#aad3cfe66d267275c3278ca0884acbcf4">More...</a><br/></td></tr>
<tr class="separator:aad3cfe66d267275c3278ca0884acbcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d195f549cd886ac8c92f8a1a15fc96a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0d195f549cd886ac8c92f8a1a15fc96a">binwidth_scott_normal_reference</a> (std::size_t n, double stdev)</td></tr>
<tr class="memdesc:a0d195f549cd886ac8c92f8a1a15fc96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the suggested binwidth according to Scott's normal reference rule.  <a href="#a0d195f549cd886ac8c92f8a1a15fc96a">More...</a><br/></td></tr>
<tr class="separator:a0d195f549cd886ac8c92f8a1a15fc96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32615ac5567a1bd2d3665f04ef03883"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ogdf::Graph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa32615ac5567a1bd2d3665f04ef03883">import_graph</a> (const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src, <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> format)</td></tr>
<tr class="memdesc:aa32615ac5567a1bd2d3665f04ef03883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a graph from a file in the specified format.  <a href="#aa32615ac5567a1bd2d3665f04ef03883">More...</a><br/></td></tr>
<tr class="separator:aa32615ac5567a1bd2d3665f04ef03883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22645b1acf63f42cc1ba99925a8c0e3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr<br class="typebreak"/>
&lt; ogdf::Graph &gt;<br class="typebreak"/>
, std::unique_ptr<br class="typebreak"/>
&lt; ogdf::GraphAttributes &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ac22645b1acf63f42cc1ba99925a8c0e3">import_layout</a> (const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src, <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> format)</td></tr>
<tr class="memdesc:ac22645b1acf63f42cc1ba99925a8c0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a layout from a file in the specified format.  <a href="#ac22645b1acf63f42cc1ba99925a8c0e3">More...</a><br/></td></tr>
<tr class="separator:ac22645b1acf63f42cc1ba99925a8c0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c50ae14cb97ff7d460f258de8501ec0"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr<br class="typebreak"/>
&lt; ogdf::Graph &gt;<br class="typebreak"/>
, std::unique_ptr<br class="typebreak"/>
&lt; ogdf::GraphAttributes &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a6c50ae14cb97ff7d460f258de8501ec0">import_layout_or_graph</a> (const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src, <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> format)</td></tr>
<tr class="memdesc:a6c50ae14cb97ff7d460f258de8501ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a layout from a file in the specified format if present; otherwise just the graph.  <a href="#a6c50ae14cb97ff7d460f258de8501ec0">More...</a><br/></td></tr>
<tr class="separator:a6c50ae14cb97ff7d460f258de8501ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d0d14354924438f964fd69cad7c9eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab2d0d14354924438f964fd69cad7c9eb">export_graph</a> (const ogdf::Graph &amp;graph, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst, <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> format)</td></tr>
<tr class="memdesc:ab2d0d14354924438f964fd69cad7c9eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a graph in a file using the default format.  <a href="#ab2d0d14354924438f964fd69cad7c9eb">More...</a><br/></td></tr>
<tr class="separator:ab2d0d14354924438f964fd69cad7c9eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc38e195638cbf6f287daa84d1fe9f6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#acc38e195638cbf6f287daa84d1fe9f6b">export_layout</a> (const ogdf::GraphAttributes &amp;attrs, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst, <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> format)</td></tr>
<tr class="memdesc:acc38e195638cbf6f287daa84d1fe9f6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a layout in a file using the default format.  <a href="#acc38e195638cbf6f287daa84d1fe9f6b">More...</a><br/></td></tr>
<tr class="separator:acc38e195638cbf6f287daa84d1fe9f6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac495fb8df270968823f59b5085382c19"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; ogdf::Graph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ac495fb8df270968823f59b5085382c19">load_graph</a> (const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src)</td></tr>
<tr class="memdesc:ac495fb8df270968823f59b5085382c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a graph from a file in the internal format.  <a href="#ac495fb8df270968823f59b5085382c19">More...</a><br/></td></tr>
<tr class="separator:ac495fb8df270968823f59b5085382c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4cfae8e516c6d836d7f20f732208f3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::unique_ptr<br class="typebreak"/>
&lt; ogdf::Graph &gt;<br class="typebreak"/>
, std::unique_ptr<br class="typebreak"/>
&lt; ogdf::GraphAttributes &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5d4cfae8e516c6d836d7f20f732208f3">load_layout</a> (const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src)</td></tr>
<tr class="memdesc:a5d4cfae8e516c6d836d7f20f732208f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a layout from a file in the internal format.  <a href="#a5d4cfae8e516c6d836d7f20f732208f3">More...</a><br/></td></tr>
<tr class="separator:a5d4cfae8e516c6d836d7f20f732208f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356eece3ce6b4c07de3ef5931b28d207"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a356eece3ce6b4c07de3ef5931b28d207">store_graph</a> (const ogdf::Graph &amp;graph, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a356eece3ce6b4c07de3ef5931b28d207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a graph in a file using the internal format.  <a href="#a356eece3ce6b4c07de3ef5931b28d207">More...</a><br/></td></tr>
<tr class="separator:a356eece3ce6b4c07de3ef5931b28d207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9133c77fdaee8ce3154111d878fe6cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9133c77fdaee8ce3154111d878fe6cba">store_layout</a> (const ogdf::GraphAttributes &amp;attrs, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a9133c77fdaee8ce3154111d878fe6cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a layout in a file using the internal format.  <a href="#a9133c77fdaee8ce3154111d878fe6cba">More...</a><br/></td></tr>
<tr class="separator:a9133c77fdaee8ce3154111d878fe6cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f982fe3da18449c8a00423b2960290c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a7f982fe3da18449c8a00423b2960290c">write_events</a> (const std::vector&lt; double &gt; &amp;data, const <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a> &amp;summary, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a7f982fe3da18449c8a00423b2960290c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes event data to a text file.  <a href="#a7f982fe3da18449c8a00423b2960290c">More...</a><br/></td></tr>
<tr class="separator:a7f982fe3da18449c8a00423b2960290c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a732420e2db87ca1137e97ca48594cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1a732420e2db87ca1137e97ca48594cb">write_frequencies</a> (const <a class="el" href="classmsc_1_1histogram.html">histogram</a> &amp;histo, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a1a732420e2db87ca1137e97ca48594cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes frequency data to a text file.  <a href="#a1a732420e2db87ca1137e97ca48594cb">More...</a><br/></td></tr>
<tr class="separator:a1a732420e2db87ca1137e97ca48594cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b4acb45b35b0af2118e96c3c4caa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a2c7b4acb45b35b0af2118e96c3c4caa4">write_density</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;density, const <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a> &amp;summary, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a2c7b4acb45b35b0af2118e96c3c4caa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes density data to a text file.  <a href="#a2c7b4acb45b35b0af2118e96c3c4caa4">More...</a><br/></td></tr>
<tr class="separator:a2c7b4acb45b35b0af2118e96c3c4caa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b05f89182c1c4addf49379e65c14774"><td class="memItemLeft" align="right" valign="top">std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1b05f89182c1c4addf49379e65c14774">check_filename</a> (std::string_view filename)</td></tr>
<tr class="memdesc:a1b05f89182c1c4addf49379e65c14774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given string can possibly be a sane file name.  <a href="#a1b05f89182c1c4addf49379e65c14774">More...</a><br/></td></tr>
<tr class="separator:a1b05f89182c1c4addf49379e65c14774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd339df403daabedc79b18fea947d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0fd339df403daabedc79b18fea947d44">check_descriptor</a> (int descriptor)</td></tr>
<tr class="memdesc:a0fd339df403daabedc79b18fea947d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the given integer can possibly be a sane file descriptor.  <a href="#a0fd339df403daabedc79b18fea947d44">More...</a><br/></td></tr>
<tr class="separator:a0fd339df403daabedc79b18fea947d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710bc5b0e7252708cd8787c6dabebf79"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string_view, <br class="typebreak"/>
std::string_view &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a710bc5b0e7252708cd8787c6dabebf79">split_filename</a> (const std::string_view filename) noexcept</td></tr>
<tr class="memdesc:a710bc5b0e7252708cd8787c6dabebf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a file name into the actual file name and an optional compression specification.  <a href="#a710bc5b0e7252708cd8787c6dabebf79">More...</a><br/></td></tr>
<tr class="separator:a710bc5b0e7252708cd8787c6dabebf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca3de98fe6236adcd1f88122ab756cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#afca3de98fe6236adcd1f88122ab756cd">is_nullio</a> (std::string_view filename) noexcept</td></tr>
<tr class="memdesc:afca3de98fe6236adcd1f88122ab756cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a file name shall be interpreted as no input or output output.  <a href="#afca3de98fe6236adcd1f88122ab756cd">More...</a><br/></td></tr>
<tr class="separator:afca3de98fe6236adcd1f88122ab756cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3669c32fb45c6df193c2123dedd7f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#adf3669c32fb45c6df193c2123dedd7f6">is_stdio</a> (std::string_view filename) noexcept</td></tr>
<tr class="memdesc:adf3669c32fb45c6df193c2123dedd7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a file name shall be interpreted as standard input or output.  <a href="#adf3669c32fb45c6df193c2123dedd7f6">More...</a><br/></td></tr>
<tr class="separator:adf3669c32fb45c6df193c2123dedd7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eebdf6d39a7e0b642f483d2c657dea"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a52eebdf6d39a7e0b642f483d2c657dea">is_fdno</a> (std::string_view filename) noexcept</td></tr>
<tr class="memdesc:a52eebdf6d39a7e0b642f483d2c657dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a file name shall be interpreted as an open file descriptor and if so, its value.  <a href="#a52eebdf6d39a7e0b642f483d2c657dea">More...</a><br/></td></tr>
<tr class="separator:a52eebdf6d39a7e0b642f483d2c657dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88330234a8601370af6522eb3105dc64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a88330234a8601370af6522eb3105dc64">guess_compression</a> (const std::string_view filename) noexcept</td></tr>
<tr class="memdesc:a88330234a8601370af6522eb3105dc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to guess the compression applied to a file from its name.  <a href="#a88330234a8601370af6522eb3105dc64">More...</a><br/></td></tr>
<tr class="separator:a88330234a8601370af6522eb3105dc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fc48a5a43bf5a36168253637ad9b2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a43fc48a5a43bf5a36168253637ad9b2b">report_io_error</a> (std::string_view filename, std::string_view message=&quot;I/O error&quot;)</td></tr>
<tr class="memdesc:a43fc48a5a43bf5a36168253637ad9b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception to report an I/O error.  <a href="#a43fc48a5a43bf5a36168253637ad9b2b">More...</a><br/></td></tr>
<tr class="separator:a43fc48a5a43bf5a36168253637ad9b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4df49d1b22a7bceb2925f374911ea59"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#af4df49d1b22a7bceb2925f374911ea59">prepare_stream</a> (boost::iostreams::filtering_istream &amp;stream, const <a class="el" href="structmsc_1_1input__file.html">input_file</a> &amp;src)</td></tr>
<tr class="memdesc:af4df49d1b22a7bceb2925f374911ea59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stacks together a chain of I/O devices and filters suitable for reading from the given source.  <a href="#af4df49d1b22a7bceb2925f374911ea59">More...</a><br/></td></tr>
<tr class="separator:af4df49d1b22a7bceb2925f374911ea59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9955cb0a44ee216397199bf3694e7882"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9955cb0a44ee216397199bf3694e7882">prepare_stream</a> (boost::iostreams::filtering_ostream &amp;stream, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dst)</td></tr>
<tr class="memdesc:a9955cb0a44ee216397199bf3694e7882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stacks together a chain of I/O devices and filters suitable for writing to the given destination.  <a href="#a9955cb0a44ee216397199bf3694e7882">More...</a><br/></td></tr>
<tr class="separator:a9955cb0a44ee216397199bf3694e7882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863e83e3c8856fa77cec9dbf905ad0cc"><td class="memTemplParams" colspan="2">template&lt;typename JsonT , typename T &gt; </td></tr>
<tr class="memitem:a863e83e3c8856fa77cec9dbf905ad0cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a863e83e3c8856fa77cec9dbf905ad0cc">make_json</a> (const std::optional&lt; T &gt; &amp;optval)</td></tr>
<tr class="memdesc:a863e83e3c8856fa77cec9dbf905ad0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a JSON object of type <code>JsonT</code> if <code>optval</code> holds a value or else <code><a class="el" href="structmsc_1_1json__null.html" title="Represents a null value. ">json_null</a></code>.  <a href="#a863e83e3c8856fa77cec9dbf905ad0cc">More...</a><br/></td></tr>
<tr class="separator:a863e83e3c8856fa77cec9dbf905ad0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d38085f9b7d9854c0772e2b4332f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ac6d38085f9b7d9854c0772e2b4332f20">make_json</a> (const std::string_view text)</td></tr>
<tr class="memdesc:ac6d38085f9b7d9854c0772e2b4332f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a JSON object of type <code><a class="el" href="structmsc_1_1json__text.html" title="Wrapper for a text value. ">json_text</a></code> if <code>text</code> is non-empty or else <code><a class="el" href="structmsc_1_1json__null.html" title="Represents a null value. ">json_null</a></code>.  <a href="#ac6d38085f9b7d9854c0772e2b4332f20">More...</a><br/></td></tr>
<tr class="separator:ac6d38085f9b7d9854c0772e2b4332f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e69b79a26d2eb707828d0f52fadf93"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ae8e69b79a26d2eb707828d0f52fadf93">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__null.html">json_null</a> &amp;obj)</td></tr>
<tr class="memdesc:ae8e69b79a26d2eb707828d0f52fadf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a <code>null</code> value as JSON.  <a href="#ae8e69b79a26d2eb707828d0f52fadf93">More...</a><br/></td></tr>
<tr class="separator:ae8e69b79a26d2eb707828d0f52fadf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4da93cd624d7222d7b736a9899276e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a6b4da93cd624d7222d7b736a9899276e">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__text.html">json_text</a> &amp;obj)</td></tr>
<tr class="memdesc:a6b4da93cd624d7222d7b736a9899276e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a text value as JSON.  <a href="#a6b4da93cd624d7222d7b736a9899276e">More...</a><br/></td></tr>
<tr class="separator:a6b4da93cd624d7222d7b736a9899276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5768ade330bae3bdd5199b20c1f15e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aef5768ade330bae3bdd5199b20c1f15e">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__bool.html">json_bool</a> &amp;obj)</td></tr>
<tr class="memdesc:aef5768ade330bae3bdd5199b20c1f15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a logical value as JSON.  <a href="#aef5768ade330bae3bdd5199b20c1f15e">More...</a><br/></td></tr>
<tr class="separator:aef5768ade330bae3bdd5199b20c1f15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1c4a3b02038ad540937ff832b9b24e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a3e1c4a3b02038ad540937ff832b9b24e">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__real.html">json_real</a> &amp;obj)</td></tr>
<tr class="memdesc:a3e1c4a3b02038ad540937ff832b9b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a real value as JSON.  <a href="#a3e1c4a3b02038ad540937ff832b9b24e">More...</a><br/></td></tr>
<tr class="separator:a3e1c4a3b02038ad540937ff832b9b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ee4acf69e739ab1f6ebc3cae84814"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9f4ee4acf69e739ab1f6ebc3cae84814">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__size.html">json_size</a> &amp;obj)</td></tr>
<tr class="memdesc:a9f4ee4acf69e739ab1f6ebc3cae84814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a size value as JSON.  <a href="#a9f4ee4acf69e739ab1f6ebc3cae84814">More...</a><br/></td></tr>
<tr class="separator:a9f4ee4acf69e739ab1f6ebc3cae84814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2424562d76592a323046a12162239d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0f2424562d76592a323046a12162239d">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__diff.html">json_diff</a> &amp;obj)</td></tr>
<tr class="memdesc:a0f2424562d76592a323046a12162239d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a difference value as JSON.  <a href="#a0f2424562d76592a323046a12162239d">More...</a><br/></td></tr>
<tr class="separator:a0f2424562d76592a323046a12162239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8520b167ebbba519a19f59d16d63e1f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#af8520b167ebbba519a19f59d16d63e1f">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__array.html">json_array</a> &amp;obj)</td></tr>
<tr class="memdesc:af8520b167ebbba519a19f59d16d63e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a JSON array.  <a href="#af8520b167ebbba519a19f59d16d63e1f">More...</a><br/></td></tr>
<tr class="separator:af8520b167ebbba519a19f59d16d63e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0893adbc22993d79c8d006c0caf90683"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0893adbc22993d79c8d006c0caf90683">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1json__object.html">json_object</a> &amp;obj)</td></tr>
<tr class="memdesc:a0893adbc22993d79c8d006c0caf90683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out a JSON object.  <a href="#a0893adbc22993d79c8d006c0caf90683">More...</a><br/></td></tr>
<tr class="separator:a0893adbc22993d79c8d006c0caf90683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a00d8ff4aa00222a3e97e6148f2982"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a56a00d8ff4aa00222a3e97e6148f2982">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a> &amp;obj)</td></tr>
<tr class="memdesc:a56a00d8ff4aa00222a3e97e6148f2982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams out any JSON value.  <a href="#a56a00d8ff4aa00222a3e97e6148f2982">More...</a><br/></td></tr>
<tr class="separator:a56a00d8ff4aa00222a3e97e6148f2982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0692ff075a812552883a04b307c388a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a0692ff075a812552883a04b307c388a7">print_meta</a> (const <a class="el" href="structmsc_1_1json__object.html">json_object</a> &amp;info, const <a class="el" href="structmsc_1_1output__file.html">output_file</a> &amp;dest)</td></tr>
<tr class="memdesc:a0692ff075a812552883a04b307c388a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes and writes the meta data in <code>info</code> to <code>dest</code>.  <a href="#a0692ff075a812552883a04b307c388a7">More...</a><br/></td></tr>
<tr class="separator:a0692ff075a812552883a04b307c388a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae251bcbbe6c7e47ec5a8c5a477cb118d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ae251bcbbe6c7e47ec5a8c5a477cb118d">normalize_layout</a> (ogdf::GraphAttributes &amp;attrs)</td></tr>
<tr class="memdesc:ae251bcbbe6c7e47ec5a8c5a477cb118d"><td class="mdescLeft">&#160;</td><td class="mdescRight">&ldquo;Normalizes&rdquo; a layout.  <a href="#ae251bcbbe6c7e47ec5a8c5a477cb118d">More...</a><br/></td></tr>
<tr class="separator:ae251bcbbe6c7e47ec5a8c5a477cb118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5534b682df2b4d77482d472d82889f7c"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT &gt; </td></tr>
<tr class="memitem:a5534b682df2b4d77482d472d82889f7c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5534b682df2b4d77482d472d82889f7c">integrate_trapezoidal</a> (FwdIterT first, FwdIterT last) noexcept</td></tr>
<tr class="memdesc:a5534b682df2b4d77482d472d82889f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the finite integral over a range given as (<em>x</em>, <em>f</em>(<em>x</em>)) points.  <a href="#a5534b682df2b4d77482d472d82889f7c">More...</a><br/></td></tr>
<tr class="separator:a5534b682df2b4d77482d472d82889f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbcbbfc5888f01a804dbc60f2b732e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#adcbcbbfc5888f01a804dbc60f2b732e0">get_coords</a> (const ogdf::GraphAttributes &amp;attrs, <a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a> v)</td></tr>
<tr class="memdesc:adcbcbbfc5888f01a804dbc60f2b732e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coordinates of a vertex in a layout.  <a href="#adcbcbbfc5888f01a804dbc60f2b732e0">More...</a><br/></td></tr>
<tr class="separator:adcbcbbfc5888f01a804dbc60f2b732e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaef22cc4e968147d17da023cc9c050"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a>, <br class="typebreak"/>
<a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#accaef22cc4e968147d17da023cc9c050">get_bounding_box</a> (const ogdf::GraphAttributes &amp;attrs) noexcept</td></tr>
<tr class="memdesc:accaef22cc4e968147d17da023cc9c050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pair containing the coordinates of the lower-left and upper-right corner of the layout's rectangular bounding box.  <a href="#accaef22cc4e968147d17da023cc9c050">More...</a><br/></td></tr>
<tr class="separator:accaef22cc4e968147d17da023cc9c050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8aa7fef957df2655aea1e3e6f9298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a60c8aa7fef957df2655aea1e3e6f9298">get_bounding_box_size</a> (const ogdf::GraphAttributes &amp;attrs) noexcept</td></tr>
<tr class="memdesc:a60c8aa7fef957df2655aea1e3e6f9298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (width and height) of the layout's rectangular bounding box.  <a href="#a60c8aa7fef957df2655aea1e3e6f9298">More...</a><br/></td></tr>
<tr class="separator:a60c8aa7fef957df2655aea1e3e6f9298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9082cf9f6a64d990da75cf2c55c7228b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="namespacemsc.html#a9a491ef1c186f808bbf89dec87e43f26">ogdf_node_array_2d</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9082cf9f6a64d990da75cf2c55c7228b">get_pairwise_shortest_paths</a> (const ogdf::Graph &amp;graph)</td></tr>
<tr class="memdesc:a9082cf9f6a64d990da75cf2c55c7228b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes all pairwise shortest paths in a graph.  <a href="#a9082cf9f6a64d990da75cf2c55c7228b">More...</a><br/></td></tr>
<tr class="separator:a9082cf9f6a64d990da75cf2c55c7228b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f208364e157791d60dde4331b5dc60"><td class="memTemplParams" colspan="2">template&lt;std::size_t Idx, typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab3f208364e157791d60dde4331b5dc60"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab3f208364e157791d60dde4331b5dc60">get</a> (<a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept-&gt; decltype(p.template get&lt; Idx &gt;())</td></tr>
<tr class="separator:ab3f208364e157791d60dde4331b5dc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ca48ccb3bf6eb20a199d346db04f25"><td class="memTemplParams" colspan="2">template&lt;std::size_t Idx, typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a68ca48ccb3bf6eb20a199d346db04f25"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a68ca48ccb3bf6eb20a199d346db04f25">get</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept-&gt; decltype(p.template get&lt; Idx &gt;())</td></tr>
<tr class="separator:a68ca48ccb3bf6eb20a199d346db04f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b87eaffbd92ad7f47d68f0cb6bf7e3"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a36b87eaffbd92ad7f47d68f0cb6bf7e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a36b87eaffbd92ad7f47d68f0cb6bf7e3">operator==</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:a36b87eaffbd92ad7f47d68f0cb6bf7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e58f19dfaf83b6829263fec30da229"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a90e58f19dfaf83b6829263fec30da229"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a90e58f19dfaf83b6829263fec30da229">operator!=</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:a90e58f19dfaf83b6829263fec30da229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a6a8e32917ac33ae70a9fd3eedf301"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a07a6a8e32917ac33ae70a9fd3eedf301"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a07a6a8e32917ac33ae70a9fd3eedf301">operator+</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:a07a6a8e32917ac33ae70a9fd3eedf301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ed5710dcdcb2533b8c89b2f466892f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a22ed5710dcdcb2533b8c89b2f466892f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a22ed5710dcdcb2533b8c89b2f466892f">operator-</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:a22ed5710dcdcb2533b8c89b2f466892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ab051ea923d1ad094087717aad6908"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a42ab051ea923d1ad094087717aad6908"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a42ab051ea923d1ad094087717aad6908">operator*</a> (const T alpha, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a42ab051ea923d1ad094087717aad6908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454b2057961b0c832dd52904f64e7866"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a454b2057961b0c832dd52904f64e7866"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a454b2057961b0c832dd52904f64e7866">operator*</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p, const T alpha) noexcept</td></tr>
<tr class="separator:a454b2057961b0c832dd52904f64e7866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b5baa39ab2ef0fb50cfeef2ab858bc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a37b5baa39ab2ef0fb50cfeef2ab858bc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a37b5baa39ab2ef0fb50cfeef2ab858bc">operator/</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p, const T alpha) noexcept</td></tr>
<tr class="separator:a37b5baa39ab2ef0fb50cfeef2ab858bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413a9b671cb4b50eb4d9c6212e11c41e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a413a9b671cb4b50eb4d9c6212e11c41e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a413a9b671cb4b50eb4d9c6212e11c41e">operator-</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a413a9b671cb4b50eb4d9c6212e11c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8064e3a72bcca49994e5836e2c899ed"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab8064e3a72bcca49994e5836e2c899ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab8064e3a72bcca49994e5836e2c899ed">dot</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:ab8064e3a72bcca49994e5836e2c899ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5297e55ece4fddb8412299444fb5bee9"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5297e55ece4fddb8412299444fb5bee9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5297e55ece4fddb8412299444fb5bee9">normsq</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept</td></tr>
<tr class="separator:a5297e55ece4fddb8412299444fb5bee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87a7023d956ed3d82f11c8cdda49ced"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab87a7023d956ed3d82f11c8cdda49ced"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab87a7023d956ed3d82f11c8cdda49ced">abs</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p) noexcept</td></tr>
<tr class="separator:ab87a7023d956ed3d82f11c8cdda49ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08e1c32c30ce3dc73ae5b7c433059cc"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab08e1c32c30ce3dc73ae5b7c433059cc"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab08e1c32c30ce3dc73ae5b7c433059cc">distance</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:ab08e1c32c30ce3dc73ae5b7c433059cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da0839211dc8149c05283002b97aa7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3da0839211dc8149c05283002b97aa7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a3da0839211dc8149c05283002b97aa7f">cross</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 3 &gt; &amp;p1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 3 &gt; &amp;p2) noexcept</td></tr>
<tr class="separator:a3da0839211dc8149c05283002b97aa7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6d993f49dbc18241c95f8fa3554443"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5a6d993f49dbc18241c95f8fa3554443"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5a6d993f49dbc18241c95f8fa3554443">make_point</a> (const T value=T{}) noexcept</td></tr>
<tr class="separator:a5a6d993f49dbc18241c95f8fa3554443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780efb5321157126f7a40784c4e319fe"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a780efb5321157126f7a40784c4e319fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a780efb5321157126f7a40784c4e319fe">make_unit_point</a> (const std::size_t idx)</td></tr>
<tr class="separator:a780efb5321157126f7a40784c4e319fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5958d51332ca522ec5118d5de1e0db49"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename EngineT , typename DistrT &gt; </td></tr>
<tr class="memitem:a5958d51332ca522ec5118d5de1e0db49"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5958d51332ca522ec5118d5de1e0db49">make_random_point</a> (EngineT &amp;rndeng, DistrT &amp;rnddst) noexcept(noexcept(rnddst(rndeng)))</td></tr>
<tr class="separator:a5958d51332ca522ec5118d5de1e0db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67a07b1481044feb8f3e222c398d7a5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af67a07b1481044feb8f3e222c398d7a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#af67a07b1481044feb8f3e222c398d7a5">make_invalid_point</a> () noexcept</td></tr>
<tr class="separator:af67a07b1481044feb8f3e222c398d7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc40962269d05b458cd8590cd81df3b"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a4bc40962269d05b458cd8590cd81df3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a4bc40962269d05b458cd8590cd81df3b">normalized</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:a4bc40962269d05b458cd8590cd81df3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ed9b65ad03f1b0ede5b31e2de02d7e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad5ed9b65ad03f1b0ede5b31e2de02d7e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ad5ed9b65ad03f1b0ede5b31e2de02d7e">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:ad5ed9b65ad03f1b0ede5b31e2de02d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409d6139f768967d62707b6ad5662d6"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5409d6139f768967d62707b6ad5662d6"><td class="memTemplItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5409d6139f768967d62707b6ad5662d6">operator&gt;&gt;</a> (std::istream &amp;istr, <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;p)</td></tr>
<tr class="separator:a5409d6139f768967d62707b6ad5662d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9101fffed55648652f9bcbf86ed79"><td class="memTemplParams" colspan="2">template&lt;typename EngineT , typename FwdIterT , typename PointT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </td></tr>
<tr class="memitem:ab4f9101fffed55648652f9bcbf86ed79"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; PointT, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab4f9101fffed55648652f9bcbf86ed79">find_primary_axes</a> (const FwdIterT first, const FwdIterT last, EngineT &amp;engine, std::integral_constant&lt; std::size_t, M &gt; dimensions={})</td></tr>
<tr class="memdesc:ab4f9101fffed55648652f9bcbf86ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a principal component analysis of an <em>N</em>-dimensional point cloud.  <a href="#ab4f9101fffed55648652f9bcbf86ed79">More...</a><br/></td></tr>
<tr class="separator:ab4f9101fffed55648652f9bcbf86ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf02ec9bdd17bc36aad02895fb3553a"><td class="memTemplParams" colspan="2">template&lt;typename EngineT , typename ContainerT , typename PointT  = typename ContainerT::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </td></tr>
<tr class="memitem:adbf02ec9bdd17bc36aad02895fb3553a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; PointT, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#adbf02ec9bdd17bc36aad02895fb3553a">find_primary_axes</a> (ContainerT &amp;coords, EngineT &amp;engine, std::integral_constant&lt; std::size_t, M &gt; dimensions={})</td></tr>
<tr class="memdesc:adbf02ec9bdd17bc36aad02895fb3553a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a principal component analysis of an <em>N</em>-dimensional point cloud.  <a href="#adbf02ec9bdd17bc36aad02895fb3553a">More...</a><br/></td></tr>
<tr class="separator:adbf02ec9bdd17bc36aad02895fb3553a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cec2e31edb64ec889ce90cc39c9999a"><td class="memTemplParams" colspan="2">template&lt;typename EngineT , typename ContainerT , typename PointT  = typename ContainerT::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </td></tr>
<tr class="memitem:a8cec2e31edb64ec889ce90cc39c9999a"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; PointT, M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8cec2e31edb64ec889ce90cc39c9999a">find_primary_axes_nondestructive</a> (ContainerT coords, EngineT &amp;engine, std::integral_constant&lt; std::size_t, M &gt; dimensions={})</td></tr>
<tr class="memdesc:a8cec2e31edb64ec889ce90cc39c9999a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a principal component analysis of an <em>N</em>-dimensional point cloud.  <a href="#a8cec2e31edb64ec889ce90cc39c9999a">More...</a><br/></td></tr>
<tr class="separator:a8cec2e31edb64ec889ce90cc39c9999a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc4a22c5168cd7f22fd553936bf96d8"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;(N &gt; 2&gt; </td></tr>
<tr class="memitem:a4cc4a22c5168cd7f22fd553936bf96d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a4cc4a22c5168cd7f22fd553936bf96d8">project_onto_plane</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;coords, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;normal)</td></tr>
<tr class="memdesc:a4cc4a22c5168cd7f22fd553936bf96d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects a point in <em>N</em>-dimensional space onto a 2-dimensional plane in that space.  <a href="#a4cc4a22c5168cd7f22fd553936bf96d8">More...</a><br/></td></tr>
<tr class="separator:a4cc4a22c5168cd7f22fd553936bf96d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379163eb32afc091b8077c3de6363512"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;(N &gt;= 2&gt; </td></tr>
<tr class="memitem:a379163eb32afc091b8077c3de6363512"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a379163eb32afc091b8077c3de6363512">transform2d</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;coords, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;e1, const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;e2)</td></tr>
<tr class="memdesc:a379163eb32afc091b8077c3de6363512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-dimensional coordinates of a point on a 2-dimensional plane in an <em>N</em>-dimensional space with respect to two freely chosen unit vectors.  <a href="#a379163eb32afc091b8077c3de6363512">More...</a><br/></td></tr>
<tr class="separator:a379163eb32afc091b8077c3de6363512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101f59c64ad99dc0e02263610a77f158"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a101f59c64ad99dc0e02263610a77f158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a101f59c64ad99dc0e02263610a77f158">isometric_projection</a> (const <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, N &gt; &amp;coords) noexcept</td></tr>
<tr class="memdesc:a101f59c64ad99dc0e02263610a77f158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-dimensional coordinates of a <em>N</em>-dimensional point's isometric projection.  <a href="#a101f59c64ad99dc0e02263610a77f158">More...</a><br/></td></tr>
<tr class="separator:a101f59c64ad99dc0e02263610a77f158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85286fb7512309a10e2ca676b1649649"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85286fb7512309a10e2ca676b1649649"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a85286fb7512309a10e2ca676b1649649">axonometric_projection</a> (<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a> type, <a class="el" href="structmsc_1_1point.html">point</a>&lt; T, 3 &gt; coords)</td></tr>
<tr class="memdesc:a85286fb7512309a10e2ca676b1649649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 2-dimensional coordinates of a 3-dimensional point's projection.  <a href="#a85286fb7512309a10e2ca676b1649649">More...</a><br/></td></tr>
<tr class="separator:a85286fb7512309a10e2ca676b1649649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb1a3f33794ed111525d9925af4978e"><td class="memTemplParams" colspan="2">template&lt;typename EngT &gt; </td></tr>
<tr class="memitem:a8bb1a3f33794ed111525d9925af4978e"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8bb1a3f33794ed111525d9925af4978e">seed_random_engine</a> (EngT &amp;engine)</td></tr>
<tr class="separator:a8bb1a3f33794ed111525d9925af4978e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e272027bff484f23cc386d0f88b22c1"><td class="memTemplParams" colspan="2">template&lt;typename EngineT &gt; </td></tr>
<tr class="memitem:a9e272027bff484f23cc386d0f88b22c1"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9e272027bff484f23cc386d0f88b22c1">random_hex_string</a> (EngineT &amp;engine, const std::size_t bytes=16)</td></tr>
<tr class="memdesc:a9e272027bff484f23cc386d0f88b22c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deterministically returns a string with the requestd number of random bytes encoded in hex.  <a href="#a9e272027bff484f23cc386d0f88b22c1">More...</a><br/></td></tr>
<tr class="separator:a9e272027bff484f23cc386d0f88b22c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7acb0a3371054d63604f954304e44c3"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename PairT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename TX  = typename std::tuple_element&lt;0, PairT&gt;::type, typename TY  = typename std::tuple_element&lt;1, PairT&gt;::type, typename T  = std::common_type_t&lt;TX, TY&gt;, typename  = std::enable_if_t&lt;std::tuple_size&lt;PairT&gt;::value == 2 and std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ad7acb0a3371054d63604f954304e44c3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ad7acb0a3371054d63604f954304e44c3">linear_regression</a> (FwdIterT first, FwdIterT last)</td></tr>
<tr class="memdesc:ad7acb0a3371054d63604f954304e44c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a simple linear regression through a data set given by a list of of unordered (<em>x</em>, <em>y</em>)-pairs.  <a href="#ad7acb0a3371054d63604f954304e44c3">More...</a><br/></td></tr>
<tr class="separator:ad7acb0a3371054d63604f954304e44c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83452b5696744740276d46978784dca3"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename PairT  = typename ContainerT::value_type, typename TX  = typename std::tuple_element&lt;0, PairT&gt;::type, typename TY  = typename std::tuple_element&lt;1, PairT&gt;::type, typename T  = std::common_type_t&lt;TX, TY&gt;, typename  = std::enable_if_t&lt;std::tuple_size&lt;PairT&gt;::value == 2 and std::is_floating_point_v&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:a83452b5696744740276d46978784dca3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a83452b5696744740276d46978784dca3">linear_regression</a> (const ContainerT &amp;container)</td></tr>
<tr class="memdesc:a83452b5696744740276d46978784dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a simple linear regression through a data set given by a list of of unordered (<em>x</em>, <em>y</em>)-pairs.  <a href="#a83452b5696744740276d46978784dca3">More...</a><br/></td></tr>
<tr class="separator:a83452b5696744740276d46978784dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f5e1dbedebd6d1c3f21e722ef2318f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa3f5e1dbedebd6d1c3f21e722ef2318f">set_resource_limits</a> ()</td></tr>
<tr class="memdesc:aa3f5e1dbedebd6d1c3f21e722ef2318f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets (soft) resource limits according to environment variables.  <a href="#aa3f5e1dbedebd6d1c3f21e722ef2318f">More...</a><br/></td></tr>
<tr class="separator:aa3f5e1dbedebd6d1c3f21e722ef2318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb606606154effcd2389f1e9f5e8b2d"><td class="memTemplParams" colspan="2">template&lt;typename KernelT &gt; </td></tr>
<tr class="memitem:adfb606606154effcd2389f1e9f5e8b2d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, <br class="typebreak"/>
double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#adfb606606154effcd2389f1e9f5e8b2d">make_density</a> (const KernelT &amp;kernel, double minval, double maxval, int points, bool normalize=true)</td></tr>
<tr class="memdesc:adfb606606154effcd2389f1e9f5e8b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the density of an event distribution over a regular grid.  <a href="#adfb606606154effcd2389f1e9f5e8b2d">More...</a><br/></td></tr>
<tr class="separator:adfb606606154effcd2389f1e9f5e8b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe3eeadf48373790babc0bf75964c24"><td class="memTemplParams" colspan="2">template&lt;typename KernelT &gt; </td></tr>
<tr class="memitem:aafe3eeadf48373790babc0bf75964c24"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; double, <br class="typebreak"/>
double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aafe3eeadf48373790babc0bf75964c24">make_density_adaptive</a> (const KernelT &amp;kernel, double minval, double maxval, bool normalize=true)</td></tr>
<tr class="memdesc:aafe3eeadf48373790babc0bf75964c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the density of an event distribution over an adaptive grid.  <a href="#aafe3eeadf48373790babc0bf75964c24">More...</a><br/></td></tr>
<tr class="separator:aafe3eeadf48373790babc0bf75964c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c44db28cd5fc85d11746011e5144496"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5c44db28cd5fc85d11746011e5144496">get_differential_entropy_of_pdf</a> (const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;density)</td></tr>
<tr class="memdesc:a5c44db28cd5fc85d11746011e5144496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the differential entropy of a probability density function.  <a href="#a5c44db28cd5fc85d11746011e5144496">More...</a><br/></td></tr>
<tr class="separator:a5c44db28cd5fc85d11746011e5144496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bdd4404e380e7ad4217d117fb9f05c"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </td></tr>
<tr class="memitem:aa1bdd4404e380e7ad4217d117fb9f05c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_arithmetic_v&lt; ValueT &gt;<br class="typebreak"/>
, std::pair&lt; ValueT, ValueT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa1bdd4404e380e7ad4217d117fb9f05c">min_max</a> (const FwdIterT first, const FwdIterT last)</td></tr>
<tr class="memdesc:aa1bdd4404e380e7ad4217d117fb9f05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum and maximum from a non-empty range of values.  <a href="#aa1bdd4404e380e7ad4217d117fb9f05c">More...</a><br/></td></tr>
<tr class="separator:aa1bdd4404e380e7ad4217d117fb9f05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71467552f971415fdb9bbd7e0456aade"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </td></tr>
<tr class="memitem:a71467552f971415fdb9bbd7e0456aade"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_arithmetic_v&lt; ValueT &gt;<br class="typebreak"/>
, std::pair&lt; ValueT, ValueT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a71467552f971415fdb9bbd7e0456aade">min_max</a> (const ContainerT &amp;container)</td></tr>
<tr class="memdesc:a71467552f971415fdb9bbd7e0456aade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum and maximum from a non-empty container of values.  <a href="#a71467552f971415fdb9bbd7e0456aade">More...</a><br/></td></tr>
<tr class="separator:a71467552f971415fdb9bbd7e0456aade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d39f8d7ad6922aafc1b4ee16d6288c"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </td></tr>
<tr class="memitem:a66d39f8d7ad6922aafc1b4ee16d6288c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, std::pair&lt; ValueT, <br class="typebreak"/>
ValueT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a66d39f8d7ad6922aafc1b4ee16d6288c">mean_stdev</a> (const FwdIterT first, const FwdIterT last)</td></tr>
<tr class="memdesc:a66d39f8d7ad6922aafc1b4ee16d6288c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arithmetic mean and standard deviation of a range of three or more values.  <a href="#a66d39f8d7ad6922aafc1b4ee16d6288c">More...</a><br/></td></tr>
<tr class="separator:a66d39f8d7ad6922aafc1b4ee16d6288c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e5c4ac0f5a5e5ef29eef621b27ddcd"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </td></tr>
<tr class="memitem:a71e5c4ac0f5a5e5ef29eef621b27ddcd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, std::pair&lt; ValueT, <br class="typebreak"/>
ValueT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a71e5c4ac0f5a5e5ef29eef621b27ddcd">mean_stdev</a> (const ContainerT &amp;container)</td></tr>
<tr class="memdesc:a71e5c4ac0f5a5e5ef29eef621b27ddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the arithmetic mean and standard deviation of a container of three or more values.  <a href="#a71e5c4ac0f5a5e5ef29eef621b27ddcd">More...</a><br/></td></tr>
<tr class="separator:a71e5c4ac0f5a5e5ef29eef621b27ddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86da94841a90a0c17c849b21e847a645"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </td></tr>
<tr class="memitem:a86da94841a90a0c17c849b21e847a645"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a86da94841a90a0c17c849b21e847a645">get_stochastic_summary</a> (const FwdIterT first, const FwdIterT last)</td></tr>
<tr class="memdesc:a86da94841a90a0c17c849b21e847a645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes numer of events, minumum, maximum, mean and RMS of a population given by a pair of forward iterators.  <a href="#a86da94841a90a0c17c849b21e847a645">More...</a><br/></td></tr>
<tr class="separator:a86da94841a90a0c17c849b21e847a645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f03ca0575d184828b0b3a6e5fa21fa"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </td></tr>
<tr class="memitem:ab6f03ca0575d184828b0b3a6e5fa21fa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab6f03ca0575d184828b0b3a6e5fa21fa">get_stochastic_summary</a> (const ContainerT &amp;container)</td></tr>
<tr class="memdesc:ab6f03ca0575d184828b0b3a6e5fa21fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes numer of events, minumum, maximum, mean and RMS of a population given by a container.  <a href="#ab6f03ca0575d184828b0b3a6e5fa21fa">More...</a><br/></td></tr>
<tr class="separator:ab6f03ca0575d184828b0b3a6e5fa21fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c4cacf83079e04382c0a69abd389c"><td class="memTemplParams" colspan="2">template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </td></tr>
<tr class="memitem:ade6c4cacf83079e04382c0a69abd389c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ade6c4cacf83079e04382c0a69abd389c">entropy</a> (const FwdIterT first, const FwdIterT last)</td></tr>
<tr class="memdesc:ade6c4cacf83079e04382c0a69abd389c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the discrete entropy of a range of frequencies.  <a href="#ade6c4cacf83079e04382c0a69abd389c">More...</a><br/></td></tr>
<tr class="separator:ade6c4cacf83079e04382c0a69abd389c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e17e4f764294c6c76eef36469d95c6b"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </td></tr>
<tr class="memitem:a5e17e4f764294c6c76eef36469d95c6b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_floating_point_v<br class="typebreak"/>
&lt; ValueT &gt;, ValueT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a5e17e4f764294c6c76eef36469d95c6b">entropy</a> (const ContainerT &amp;container)</td></tr>
<tr class="memdesc:a5e17e4f764294c6c76eef36469d95c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the discrete entropy of a container of frequencies.  <a href="#a5e17e4f764294c6c76eef36469d95c6b">More...</a><br/></td></tr>
<tr class="separator:a5e17e4f764294c6c76eef36469d95c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495410bfc77a46070a2c41f4cf23b6d5"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a495410bfc77a46070a2c41f4cf23b6d5">operator&lt;&lt;</a> (std::ostream &amp;ostr, const <a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a> &amp;pr)</td></tr>
<tr class="memdesc:a495410bfc77a46070a2c41f4cf23b6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an informal representation of <code>pr</code> into <code>ostr</code>.  <a href="#a495410bfc77a46070a2c41f4cf23b6d5">More...</a><br/></td></tr>
<tr class="separator:a495410bfc77a46070a2c41f4cf23b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2181a24ee8fbb7f9ee51b596a00535"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aef2181a24ee8fbb7f9ee51b596a00535">compute_stress</a> (const ogdf::GraphAttributes &amp;attrs, double nodesep=<a class="el" href="namespacemsc.html#a9c9ae02864f293bda20ee14ba2b72e96">default_node_distance</a>)</td></tr>
<tr class="memdesc:aef2181a24ee8fbb7f9ee51b596a00535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the stress of a given layout.  <a href="#aef2181a24ee8fbb7f9ee51b596a00535">More...</a><br/></td></tr>
<tr class="separator:aef2181a24ee8fbb7f9ee51b596a00535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e96f24af01cdc374c1fd95bcc2544cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8e96f24af01cdc374c1fd95bcc2544cf">compute_stress_fit_nodesep</a> (const ogdf::GraphAttributes &amp;attrs)</td></tr>
<tr class="memdesc:a8e96f24af01cdc374c1fd95bcc2544cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the adaptive stress of a given layout.  <a href="#a8e96f24af01cdc374c1fd95bcc2544cf">More...</a><br/></td></tr>
<tr class="separator:a8e96f24af01cdc374c1fd95bcc2544cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803a6cb8d58b82af222165df1e637720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a803a6cb8d58b82af222165df1e637720">compute_stress_fit_scale</a> (const ogdf::GraphAttributes &amp;attrs)</td></tr>
<tr class="memdesc:a803a6cb8d58b82af222165df1e637720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the adaptive stress of a given layout.  <a href="#a803a6cb8d58b82af222165df1e637720">More...</a><br/></td></tr>
<tr class="separator:a803a6cb8d58b82af222165df1e637720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61ade32bc027d2d6270cbd2dd21e3cc"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:aa61ade32bc027d2d6270cbd2dd21e3cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::conjunction_v<br class="typebreak"/>
&lt; std::is_convertible&lt; Ts, <br class="typebreak"/>
std::string_view &gt;<br class="typebreak"/>
...&gt;, std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#aa61ade32bc027d2d6270cbd2dd21e3cc">concat</a> (Ts &amp;&amp;...parts)</td></tr>
<tr class="memdesc:aa61ade32bc027d2d6270cbd2dd21e3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates zero or more string-like objects.  <a href="#aa61ade32bc027d2d6270cbd2dd21e3cc">More...</a><br/></td></tr>
<tr class="separator:aa61ade32bc027d2d6270cbd2dd21e3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a0148100643bf0f12a1643dd892e31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ae0a0148100643bf0f12a1643dd892e31">startswith</a> (const std::string_view text, const std::string_view prefix) noexcept</td></tr>
<tr class="memdesc:ae0a0148100643bf0f12a1643dd892e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether <code>prefix</code> is a prefix of <code>text</code>.  <a href="#ae0a0148100643bf0f12a1643dd892e31">More...</a><br/></td></tr>
<tr class="separator:ae0a0148100643bf0f12a1643dd892e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8954a626ade1847488523f292b9b5314"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a8954a626ade1847488523f292b9b5314">endswith</a> (const std::string_view text, const std::string_view suffix) noexcept</td></tr>
<tr class="memdesc:a8954a626ade1847488523f292b9b5314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether <code>suffix</code> is a suffix of <code>text</code>.  <a href="#a8954a626ade1847488523f292b9b5314">More...</a><br/></td></tr>
<tr class="separator:a8954a626ade1847488523f292b9b5314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b8dbfad6f34e0ea1f5146e3c1f91ce"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:ac7b8dbfad6f34e0ea1f5146e3c1f91ce"><td class="memTemplItemLeft" align="right" valign="top">IterT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ac7b8dbfad6f34e0ea1f5146e3c1f91ce">cyclic_next</a> (const IterT iter, const IterT first, const IterT last)</td></tr>
<tr class="memdesc:ac7b8dbfad6f34e0ea1f5146e3c1f91ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the next item in a sequence, wrapping over to the first at the end.  <a href="#ac7b8dbfad6f34e0ea1f5146e3c1f91ce">More...</a><br/></td></tr>
<tr class="separator:ac7b8dbfad6f34e0ea1f5146e3c1f91ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46488066f524876bfa4d58e47866f08f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , typename T  = typename ContainerT::value_type&gt; </td></tr>
<tr class="memitem:a46488066f524876bfa4d58e47866f08f"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a46488066f524876bfa4d58e47866f08f">get_item</a> (const ContainerT &amp;container, const std::size_t index)</td></tr>
<tr class="memdesc:a46488066f524876bfa4d58e47866f08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element at the specified index of a container if it exists.  <a href="#a46488066f524876bfa4d58e47866f08f">More...</a><br/></td></tr>
<tr class="separator:a46488066f524876bfa4d58e47866f08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf446f1e4a9e8b5b38c6adfe1a3bfd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cf446f1e4a9e8b5b38c6adfe1a3bfd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a7cf446f1e4a9e8b5b38c6adfe1a3bfd8">get_same</a> (const std::initializer_list&lt; T &gt; items)</td></tr>
<tr class="memdesc:a7cf446f1e4a9e8b5b38c6adfe1a3bfd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a non-empty list of equal values, returns the first value.  <a href="#a7cf446f1e4a9e8b5b38c6adfe1a3bfd8">More...</a><br/></td></tr>
<tr class="separator:a7cf446f1e4a9e8b5b38c6adfe1a3bfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d65d9e29775a99128adce17964695d"><td class="memTemplParams" colspan="2">template&lt;typename TargetT , typename SourceT &gt; </td></tr>
<tr class="memitem:a93d65d9e29775a99128adce17964695d"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; TargetT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a93d65d9e29775a99128adce17964695d">optional_cast</a> (std::optional&lt; SourceT &gt; src) noexcept(std::is_nothrow_move_constructible_v&lt; TargetT &gt;)</td></tr>
<tr class="memdesc:a93d65d9e29775a99128adce17964695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the <code>src</code> contains a value (of type <code>SourceT</code>), it is <code>static_cast</code> to <code>TargetT</code> and returned as a new optional value; otherwise, an empty optional is returned.  <a href="#a93d65d9e29775a99128adce17964695d">More...</a><br/></td></tr>
<tr class="separator:a93d65d9e29775a99128adce17964695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ccc8eccb210f2cfae085d3f311174"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a048ccc8eccb210f2cfae085d3f311174"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::shared_ptr&lt; T1 &gt;<br class="typebreak"/>
, std::shared_ptr&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a048ccc8eccb210f2cfae085d3f311174">share_pair</a> (std::pair&lt; std::unique_ptr&lt; T1 &gt;, std::unique_ptr&lt; T2 &gt;&gt; duo)</td></tr>
<tr class="memdesc:a048ccc8eccb210f2cfae085d3f311174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a pair of shared pointers from a pair of unique pointers via the respective conversion constructor.  <a href="#a048ccc8eccb210f2cfae085d3f311174">More...</a><br/></td></tr>
<tr class="separator:a048ccc8eccb210f2cfae085d3f311174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5a23daf06e36ca12201ac66c3c5d8b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a1e5a23daf06e36ca12201ac66c3c5d8b">normalize_constant_name</a> (const std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a1e5a23daf06e36ca12201ac66c3c5d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a textual constant name (as it might appear in JSON) in order to prepare it for being converted to a C++ enumerator constant.  <a href="#a1e5a23daf06e36ca12201ac66c3c5d8b">More...</a><br/></td></tr>
<tr class="separator:a1e5a23daf06e36ca12201ac66c3c5d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8978d9102ba0043fc2d74ab8987dcfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab8978d9102ba0043fc2d74ab8987dcfa">reject_invalid_enumeration</a> (int value, std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:ab8978d9102ba0043fc2d74ab8987dcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports an error due to an invalid enumerator constant.  <a href="#ab8978d9102ba0043fc2d74ab8987dcfa">More...</a><br/></td></tr>
<tr class="separator:ab8978d9102ba0043fc2d74ab8987dcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e7e9c0b7dec60a1b69c6e0d603cc3f"><td class="memTemplParams" colspan="2">template&lt;typename EnumT &gt; </td></tr>
<tr class="memitem:a13e7e9c0b7dec60a1b69c6e0d603cc3f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t<br class="typebreak"/>
&lt; std::is_enum_v&lt; EnumT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a13e7e9c0b7dec60a1b69c6e0d603cc3f">reject_invalid_enumeration</a> (const EnumT value, const std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:a13e7e9c0b7dec60a1b69c6e0d603cc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for <code>reject_invalid_enumeration</code> when the constant is already of the enumeration's type.  <a href="#a13e7e9c0b7dec60a1b69c6e0d603cc3f">More...</a><br/></td></tr>
<tr class="separator:a13e7e9c0b7dec60a1b69c6e0d603cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3a6c9420589b0a6b395c789d1323f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ac7d3a6c9420589b0a6b395c789d1323f">reject_invalid_enumeration</a> (std::string_view value, std::string_view <a class="el" href="namespacemsc.html#a0ed835959c86eb037e762c3ff06655e6">name</a>)</td></tr>
<tr class="memdesc:ac7d3a6c9420589b0a6b395c789d1323f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports an error due to an invalid enumerator name.  <a href="#ac7d3a6c9420589b0a6b395c789d1323f">More...</a><br/></td></tr>
<tr class="separator:ac7d3a6c9420589b0a6b395c789d1323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84a5f91060ba6302c7a24fe94a722f8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ab84a5f91060ba6302c7a24fe94a722f8">parse_decimal_number</a> (std::string_view text) noexcept</td></tr>
<tr class="memdesc:ab84a5f91060ba6302c7a24fe94a722f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests whether a string parses as decimal number and if so returns its value.  <a href="#ab84a5f91060ba6302c7a24fe94a722f8">More...</a><br/></td></tr>
<tr class="separator:ab84a5f91060ba6302c7a24fe94a722f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658ee284c6eecb26a46aa760523a7efb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a658ee284c6eecb26a46aa760523a7efb"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if_t<br class="typebreak"/>
&lt; std::is_arithmetic_v&lt; T &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a658ee284c6eecb26a46aa760523a7efb">square</a> (const T x) noexcept</td></tr>
<tr class="memdesc:a658ee284c6eecb26a46aa760523a7efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squares a number.  <a href="#a658ee284c6eecb26a46aa760523a7efb">More...</a><br/></td></tr>
<tr class="separator:a658ee284c6eecb26a46aa760523a7efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad73f1162b3a285e72f31c41075f49f52"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#ad73f1162b3a285e72f31c41075f49f52">internal_file_format</a></td></tr>
<tr class="memdesc:ad73f1162b3a285e72f31c41075f49f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Preferred graph and layout file format.  <a href="#ad73f1162b3a285e72f31c41075f49f52">More...</a><br/></td></tr>
<tr class="separator:ad73f1162b3a285e72f31c41075f49f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9ae02864f293bda20ee14ba2b72e96"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemsc.html#a9c9ae02864f293bda20ee14ba2b72e96">default_node_distance</a></td></tr>
<tr class="memdesc:a9c9ae02864f293bda20ee14ba2b72e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Average edge length in normalized layouts.  <a href="#a9c9ae02864f293bda20ee14ba2b72e96">More...</a><br/></td></tr>
<tr class="separator:a9c9ae02864f293bda20ee14ba2b72e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Top-level name-space for pretty much everything in this project. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a4a63a9d3b73b9aa1106194c6d9f5610b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a4a63a9d3b73b9aa1106194c6d9f5610b">msc::planar_line</a> = typedef std::pair&lt;<a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 2&gt;, <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 2&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Planar line represented by its start and end points. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type used to represent coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dd98b85959d8bf574c6a2c4315baf6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">msc::json_any</a> = typedef std::variant&lt; <a class="el" href="structmsc_1_1json__null.html">json_null</a>, <a class="el" href="structmsc_1_1json__text.html">json_text</a>, <a class="el" href="structmsc_1_1json__bool.html">json_bool</a>, <a class="el" href="structmsc_1_1json__real.html">json_real</a>, <a class="el" href="structmsc_1_1json__size.html">json_size</a>, <a class="el" href="structmsc_1_1json__diff.html">json_diff</a>, <a class="el" href="structmsc_1_1json__array.html">json_array</a>, <a class="el" href="structmsc_1_1json__object.html">json_object</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polymorphic type holding any JSON value (including <code>null</code>). </p>

</div>
</div>
<a class="anchor" id="a8194fd1e1916ad4a3dee4298bd3f912f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a8194fd1e1916ad4a3dee4298bd3f912f">msc::ogdf_node_array_1d</a> = typedef ogdf::NodeArray&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient type alias for a node property. </p>

</div>
</div>
<a class="anchor" id="a9a491ef1c186f808bbf89dec87e43f26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a9a491ef1c186f808bbf89dec87e43f26">msc::ogdf_node_array_2d</a> = typedef ogdf::NodeArray&lt;ogdf::NodeArray&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient type alias for a pairwise node property. </p>

</div>
</div>
<a class="anchor" id="a453b2e80f3f642cd10f6766efc95edaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a453b2e80f3f642cd10f6766efc95edaa">msc::node_pair</a> = typedef std::pair&lt;<a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a>, <a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenient type alias for a pair of node pointers. </p>

</div>
</div>
<a class="anchor" id="ab7642ca88d0f3d1b6a8914ece4c0681e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a> = typedef <a class="el" href="structmsc_1_1point.html">point</a>&lt;double, 2&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a92096d34308c14b65f1ef6c7c1f47970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemsc.html#a92096d34308c14b65f1ef6c7c1f47970">msc::point3d</a> = typedef <a class="el" href="structmsc_1_1point.html">point</a>&lt;double, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a196b5b50d942eacd26d97544a70ff3ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a196b5b50d942eacd26d97544a70ff3ca">msc::stress_modi</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration type that is used in the CLI. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a196b5b50d942eacd26d97544a70ff3caacec315e3d0975e5cc2811d5d8725f149"></a>fixed</em>&nbsp;</td><td class="fielddoc">
<p>use fixed scale and default node distance </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a196b5b50d942eacd26d97544a70ff3caa05347f66d710a82340c847fa8c9715bc"></a>fit_nodesep</em>&nbsp;</td><td class="fielddoc">
<p>fit quadratic parabola against node distance and report minimum </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a196b5b50d942eacd26d97544a70ff3caa57333065c549c0468a640e39c0beee65"></a>fit_scale</em>&nbsp;</td><td class="fielddoc">
<p>fit quadratic parabola against scale using default node distance and report minimum </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a93a867f812a195890b25dc49b0c14c9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">msc::algorithms</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common layouting algorithms. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a93a867f812a195890b25dc49b0c14c9bad833560a6ffadaad4d5e2394c9423c0d"></a>davidson_harel</em>&nbsp;</td><td class="fielddoc">
<p>Davidson-Harel layout algorithm. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a93a867f812a195890b25dc49b0c14c9ba390f9159ed37c3e8cd6037428d12675b"></a>fmmm</em>&nbsp;</td><td class="fielddoc">
<p>fast multipole multilevel layouting algorithm </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a93a867f812a195890b25dc49b0c14c9bafd82954f9da15c655bee87e77a9cb693"></a>pivot_mds</em>&nbsp;</td><td class="fielddoc">
<p>pivot MDS (multi-dimensional scaling) layout algorithm </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a93a867f812a195890b25dc49b0c14c9ba076e42393fe86659e9e81c9d6c62b048"></a>spring_embedder_kk</em>&nbsp;</td><td class="fielddoc">
<p>spring-embedder layout algorithm by Kamada and Kawai </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a93a867f812a195890b25dc49b0c14c9bae10a36f1a5231e597daf8f42dc1ab55a"></a>stress</em>&nbsp;</td><td class="fielddoc">
<p>energy-based layout using stress minimization </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a5396b55ae4ea5a0cf2e7add71dca29ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">msc::binnings</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Histogram binning strategies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a5396b55ae4ea5a0cf2e7add71dca29eda86e705c00d780fb4de3f94c67b2d7156"></a>fixed_count</em>&nbsp;</td><td class="fielddoc">
<p>use a fixed bin count </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5396b55ae4ea5a0cf2e7add71dca29eda792851d0725ebe3fa785587003647fe9"></a>fixed_width</em>&nbsp;</td><td class="fielddoc">
<p>use a fixed bin width </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a5396b55ae4ea5a0cf2e7add71dca29edab1d6c4aa2c3a72bb602d19031a759a86"></a>scott_normal_reference</em>&nbsp;</td><td class="fielddoc">
<p>use Scott's normal reference rule to select the bin width </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af083baa2f5eeb44f148fd49aa50b2caf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">msc::compressions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data compression stratagies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="af083baa2f5eeb44f148fd49aa50b2cafa2bd9c0ed00116be1258e0cc66617d7c8"></a>automatic</em>&nbsp;</td><td class="fielddoc">
<p>guess compression from the file name extension </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af083baa2f5eeb44f148fd49aa50b2cafa03ce1ba314f367fdd09887fc8f60578b"></a>bzip2</em>&nbsp;</td><td class="fielddoc">
<p>use bzip2 compression </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af083baa2f5eeb44f148fd49aa50b2cafa749cadba7b2ed8d4a2aaa91a9cb1896c"></a>gzip</em>&nbsp;</td><td class="fielddoc">
<p>use gzip compression </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="af083baa2f5eeb44f148fd49aa50b2cafa334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none</em>&nbsp;</td><td class="fielddoc">
<p>don't use any compression </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae26ed6099a182e487884926c1a32e4f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">msc::distributions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Real random distributions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae26ed6099a182e487884926c1a32e4f0afea087517c26fadd409bd4b9dc642555"></a>normal</em>&nbsp;</td><td class="fielddoc">
<p>normal (Gaussian) distribution </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae26ed6099a182e487884926c1a32e4f0aa489ffed938ef1b9e86889bc413501ee"></a>uniform</em>&nbsp;</td><td class="fielddoc">
<p>uniform real distribution </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">msc::fileformats</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Graph (and layout) file formats. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba1d28d258250876fb7dde22a17436ef9c"></a>bench</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba3d0e38abf71c7e0333d0a02b0ab788c5"></a>chaco</em>&nbsp;</td><td class="fielddoc">
<p><a href="https://cfwebprod.sandia.gov/cfdocs/CompResearch/docs/guide.pdf">https://cfwebprod.sandia.gov/cfdocs/CompResearch/docs/guide.pdf</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba01a120c756b1f6cf4f08e0fca0cfa6fe"></a>dl</em>&nbsp;</td><td class="fielddoc">
<p>UCINET DL format: <a href="https://sites.google.com/site/ucinetsoftware/document/ucinethelp.htm">https://sites.google.com/site/ucinetsoftware/document/ucinethelp.htm</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba95d82d6d9634b7fa4150a62669f29963"></a>dmf</em>&nbsp;</td><td class="fielddoc">
<p>DIMACS Max Flow Challenge: <a href="ftp://dimacs.rutgers.edu/pub/netflow/">ftp://dimacs.rutgers.edu/pub/netflow/</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba69eb76c88557a8211cbfc9beda5fc062"></a>dot</em>&nbsp;</td><td class="fielddoc">
<p><a href="http://www.graphviz.org/doc/info/lang.html">http://www.graphviz.org/doc/info/lang.html</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbae00eb494cdde999c956da60f5183c69b"></a>gd_challenge</em>&nbsp;</td><td class="fielddoc">
<p>Graph Drawing Challenge: Area Minimization for Orthogonal Grid Layouts <a href="http://graphdrawing.de/contest2013/challenge.html">http://graphdrawing.de/contest2013/challenge.html</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba44fdb916a558ef6739cfa6378de4995a"></a>gdf</em>&nbsp;</td><td class="fielddoc">
<p>GUESS Database File: <a href="http://graphexploration.cond.org/manual.html">http://graphexploration.cond.org/manual.html</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbad3828e428256f735a669a4a8a5624ca0"></a>gexf</em>&nbsp;</td><td class="fielddoc">
<p>Graph Exchange XML Format: <a href="https://gephi.org/gexf/format/">https://gephi.org/gexf/format/</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba4827b0d87596b184031d769793484066"></a>gml</em>&nbsp;</td><td class="fielddoc">
<p>Graph Modelling Language: <a href="https://en.wikipedia.org/wiki/Graph_Modelling_Language">https://en.wikipedia.org/wiki/Graph_Modelling_Language</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbae0a07cd7e15ec78299781c74556967cd"></a>graph6</em>&nbsp;</td><td class="fielddoc">
<p>The Graph6 format represents a (preferable dense or small) simple undirected graph as a string containing printable characters between 0x3F and 0x7E. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbaba9fdc484f1b426d287cc20e9a8cb3dd"></a>graphml</em>&nbsp;</td><td class="fielddoc">
<p>Graph Markup Language: <a href="http://graphml.graphdrawing.org/">http://graphml.graphdrawing.org/</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba68e3d3ca71bae332832b42bb38df7503"></a>leda</em>&nbsp;</td><td class="fielddoc">
<p>LEDA Native File Format for Graphs: <a href="http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html">http://www.algorithmic-solutions.info/leda_guide/graphs/leda_native_graph_fileformat.html</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba98edc8fd111d10b528b4f84d5968db03"></a>matrix_market</em>&nbsp;</td><td class="fielddoc">
<p><a href="http://math.nist.gov/MatrixMarket/formats.html">http://math.nist.gov/MatrixMarket/formats.html</a> </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbabf688cefd04199b5dff3abe33ceafb28"></a>pla</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba006b3a2ef99493587eb654bee633b1e4"></a>pm_diss_graph</em>&nbsp;</td><td class="fielddoc">
<p>Graph file format from Petra Mutzel's PhD thesis. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba60d99e58d66a5e0f4f89ec3ddd1d9a80"></a>rome</em>&nbsp;</td><td class="fielddoc">
<p>Rome-Lib format: <a href="http://www.graphdrawing.org/data/">http://www.graphdrawing.org/data/</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbacfce9735de7c3873a55331a4e74b70fc"></a>rudy</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcba1514ef4c38ef3b21bf970755926aadde"></a>stp</em>&nbsp;</td><td class="fielddoc">
<p>SteinLib STP Data Format: <a href="http://steinlib.zib.de/format.php">http://steinlib.zib.de/format.php</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbaf666ad4dc5d95bac7f35964e7d56e41e"></a>tlp</em>&nbsp;</td><td class="fielddoc">
<p>Tulip software graph format: <a href="http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format">http://tulip.labri.fr/TulipDrupal/?q=tlp-file-format</a>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ad45abf669ad17a61f470330d16a9cbcbaf5bf82d97a89bd886096bec297de50ef"></a>ygraph</em>&nbsp;</td><td class="fielddoc">
<p><a href="http://www3.cs.stonybrook.edu/~algorith/implement/nauty/distrib/makebg.c">http://www3.cs.stonybrook.edu/~algorith/implement/nauty/distrib/makebg.c</a> </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a196c75041f232c8f8c22d81fd90b8274"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">msc::kernels</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data aggregation and presentation strategies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a196c75041f232c8f8c22d81fd90b8274a2f3e3aba4608b6c748b182f722c8f6f0"></a>boxed</em>&nbsp;</td><td class="fielddoc">
<p>histogram with equally-sized bins </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a196c75041f232c8f8c22d81fd90b8274a304e2a3b544f6b9f267a151e1bcee487"></a>gaussian</em>&nbsp;</td><td class="fielddoc">
<p>smooth gliding average using a gaussian kernel </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a196c75041f232c8f8c22d81fd90b8274abdd166af3a63f7be696dd17a218a6ffb"></a>raw</em>&nbsp;</td><td class="fielddoc">
<p>raw event data </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aa7a30e3eb0cf1bdd3810114605f47475"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">msc::projections</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Graphical projection types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa7a30e3eb0cf1bdd3810114605f47475a21a0862152ed5785891fbdbd42a5062a"></a>isometric</em>&nbsp;</td><td class="fielddoc">
<p>isometric projection (axonometric) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa7a30e3eb0cf1bdd3810114605f47475a1ee509d64a5d1462e497b9f5ed0c73cb"></a>ortho_front</em>&nbsp;</td><td class="fielddoc">
<p>front-view orthographic projection (axonometric) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa7a30e3eb0cf1bdd3810114605f47475abd74f9aa9b8093fee262f2b2a9d2f26b"></a>ortho_side</em>&nbsp;</td><td class="fielddoc">
<p>side-view orthographic projection (axonometric) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa7a30e3eb0cf1bdd3810114605f47475a2c3403610f89b5948c4fc62d04549422"></a>ortho_top</em>&nbsp;</td><td class="fielddoc">
<p>top-view orthographic projection (axonometric) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9e4f85e669d8d8947ab2fafa95dd6598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">msc::terminals</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I/O terminal types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9e4f85e669d8d8947ab2fafa95dd6598ada3f6396c032b006442940855c25dfd8"></a>descriptor</em>&nbsp;</td><td class="fielddoc">
<p>terminal connected to an existing open file specified by its numeric descriptor </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e4f85e669d8d8947ab2fafa95dd6598a8c7dd922ad47494fc02c388e12c00eac"></a>file</em>&nbsp;</td><td class="fielddoc">
<p>terimal connected to an entry in the file-system </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e4f85e669d8d8947ab2fafa95dd6598a37a6259cc0c1dae299a7866489dff0bd"></a>null</em>&nbsp;</td><td class="fielddoc">
<p>null terminal with semantics similar to /dev/null on POSIX </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a9e4f85e669d8d8947ab2fafa95dd6598a4435f0f89633053c96204ebf23d6ea4e"></a>stdio</em>&nbsp;</td><td class="fielddoc">
<p>standard input or output terminal </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2016583431e89758955af6974010aa20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">msc::treatments</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strategies for handling arithmetically undefined results. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1"></a>exception</em>&nbsp;</td><td class="fielddoc">
<p>throw an exception and give up on the computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2016583431e89758955af6974010aa20a567bc1d268f135496de3d5b946b691f3"></a>ignore</em>&nbsp;</td><td class="fielddoc">
<p>pretend the value causing trouble does not exist and carry on with the computation </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2016583431e89758955af6974010aa20a9dde360102c103867bd2f45872f1129c"></a>replace</em>&nbsp;</td><td class="fielddoc">
<p>replace the result by a sentinel value (usually NaN) and carry on with the computation </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0b1c3f2ee5b986fd5b89decc81f45939"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; msc::get_all_angles_between_adjacent_incident_edges </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">treatments&#160;</td>
          <td class="paramname"><em>treatment</em> = <code>treatments::exception</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all angles between adjacent incident edges. </p>
<p>For vertices with degree 1 an angle of 2 &pi; will be reported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to operate on</td></tr>
    <tr><td class="paramname">treatment</td><td>strategy for treating non-finite angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>angles in unspecified order </dd></dl>

</div>
</div>
<a class="anchor" id="ab68ee3f8090280fc7a62065b34cb8cd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int msc::guess_terminal_width </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fallback</em> = <code>80</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Guesses the width of the output terminal. </p>
<p>If the environment variable <code>COLUMNS</code> is set and can be parsed as an integer with a value in the interval <code>(0, INT_MAX]</code>, that value is returned. Otherwise, <code>fallback</code> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fallback</td><td>value to return as a last resort</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>guestimated terminal width in columns </dd></dl>

</div>
</div>
<a class="anchor" id="a111ece927b75ddfc23e8c95e75cb5cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::check_stdio </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether standard input or output are in an error state. </p>
<p>EOF is not considered an error state.</p>
<p>The intended use of this function is to be called at the end of <code>main</code> as <code>check_stdio(std::cin, std::cout)</code> to make sure I/O errors are not silently passed over.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>standard input stream</td></tr>
    <tr><td class="paramname">output</td><td>standard output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>if either stream is not okay </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77afadb2a5ac037be127482c79b55954"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::check_stdio </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether standard input or output are in an error state. </p>
<p>This function performs the same check as the throwing overload but instead of throwing an exception returns whether the streams were both okay and, if they are not, provides an appropriate error message.</p>
<p>In the rare event that assigning to the string required a memory reallocation that fails, <code>std::terminate</code> will be called. If this is a concern, make sure to <code>reserve()</code> sufficient space in the string beforehand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>standard input stream</td></tr>
    <tr><td class="paramname">output</td><td>standard output stream</td></tr>
    <tr><td class="paramname">message</td><td>if <code>false</code> is returned, an error message is assigned to the string, otherwise, it is left unchanged</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether both streams are okay </dd></dl>

</div>
</div>
<a class="anchor" id="a352ce49a25a232580ff6f3c23676dc63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; msc::helptext_file_name_expansion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides a generic message that informs the user about the expansion of <code>%</code> characters in file names. </p>
<dl class="section return"><dt>Returns</dt><dd>generic help text </dd></dl>

</div>
</div>
<a class="anchor" id="aa1dad6fa2e1e264b66bc570b2b2ad3aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1output__file.html">output_file</a> msc::expand_filename </td>
          <td>(</td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>iteration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a file name by replacing each <code>%</code> in <code>pattern.filename()</code> by a string representation of <code>iteration</code>. </p>
<p>This function returns a verbatim copy of <code>pattern</code> unless <code>pattern.terminal() == <a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598a8c7dd922ad47494fc02c388e12c00eac" title="terimal connected to an entry in the file-system ">terminals::file</a></code>. The terminal and compression attributes are preserved in every case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>file name pattern (including zero or more <code>%</code> characters)</td></tr>
    <tr><td class="paramname">iteration</td><td>counter to substitute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expanded file name </dd></dl>

</div>
</div>
<a class="anchor" id="afce81081f8150e86ca72e6eacd0002f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1output__file.html">output_file</a> msc::expand_filename </td>
          <td>(</td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>minor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a file name by replacing the first and second <code>%</code> in <code>pattern.filename()</code> by a string representation of <code>major</code> and <code>minor</code> respectively. </p>
<p>This function returns a verbatim copy of <code>pattern</code> unless <code>pattern.terminal() == <a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598a8c7dd922ad47494fc02c388e12c00eac" title="terimal connected to an entry in the file-system ">terminals::file</a></code>. The terminal and compression attributes are preserved in every case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>file name pattern (including zero, one or two <code>%</code> characters)</td></tr>
    <tr><td class="paramname">major</td><td>first counter to substitute</td></tr>
    <tr><td class="paramname">minor</td><td>second counter to substitute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>expanded file name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the file name contains more than three <code>%</code> characters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20cd9702266c76722a07ce54d61021e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename CuboidT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename PointT  = typename CuboidT::point_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;ogdf::Graph&gt;, std::unique_ptr&lt;ogdf::GraphAttributes&gt; &gt; msc::convert_and_project </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function was considered useful at one point but is undocumented, untested and unused at the moment. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward-iterator type that dereferences to a <code>cuboid</code> instantiation</td></tr>
    <tr><td class="paramname">CuboidT</td><td>type of the cuboids to project</td></tr>
    <tr><td class="paramname">PointT</td><td>type of the cuboid's corners</td></tr>
    <tr><td class="paramname">T</td><td>type of the cuboid's corner's coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the cuboid</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first cuboid to project</td></tr>
    <tr><td class="paramname">last</td><td>iterator past the last cuboid to project</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and native layout derived from projecting the cuboids </dd></dl>

</div>
</div>
<a class="anchor" id="a4155dfdaf0b13e32a8d32903cbcb2248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;double, double&gt; &gt; msc::initialize_entropies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an object that is ready to use as collector for entropy data. </p>
<dl class="section return"><dt>Returns</dt><dd>empty vector of appropriate type </dd></dl>

</div>
</div>
<a class="anchor" id="a12ec8640424a697ab771e2971b62f6d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::append_entropy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>entropies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_object &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>keyname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>valname</em> = <code>&quot;entropy&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends the entropy of an analysis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entropies</td><td>data structire to append to</td></tr>
    <tr><td class="paramname">info</td><td>data structure to extract information from</td></tr>
    <tr><td class="paramname">keyname</td><td>name of the independent variable in <code>info</code></td></tr>
    <tr><td class="paramname">valname</td><td>name of the dependent variable in <code>info</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9449e0bd58945761e8d4a097b645a0e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::assign_entropy_regression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>entropies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">json_object &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a linear regression over the data held in <code>entropies</code> and assigns the result as <code>entropy-intercept</code> and <code>entropy-slope</code> to <code>info</code>. </p>
<p>If <code>entropies.empty()</code> this function has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entropies</td><td>collected data points</td></tr>
    <tr><td class="paramname">info</td><td>data structure to assign to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3837ff533f6a2a40ac20b5af9c6e382f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto msc::find_edge_crossings </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td> -&gt;  std::vector&lt; std::tuple&lt; point2d, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a>, <a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a> &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the coordinates of all (real) edge crossings (between non-adjacent edges) in a layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to find edge crossings in</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of triples <code>(p, e1, e2)</code> of the coordinates <code>p</code> of the intersection between edges <code>e1</code> and <code>e2</code> </dd></dl>

</div>
</div>
<a class="anchor" id="adc29e0942012bbf9887ad83888ebb109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto msc::get_crossing_angle </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a>&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceogdf.html#ab994e376393ed171d84732d377289881">ogdf::edge</a>&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  double</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the crossing angle between edges <code>e</code> and <code>e2</code> in layout <code>attrs</code>. </p>
<p>The behavior is undefined if <code>e1</code> and <code>e2</code> are not edges in <code>attrs.getConstGraph()</code> or don't intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to consider</td></tr>
    <tr><td class="paramname">e1</td><td>first edge</td></tr>
    <tr><td class="paramname">e2</td><td>second edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>angle between <code>e1</code> and <code>e2</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a56d30898c88b8f84fa3ab7171c6ecade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto msc::check_intersect </td>
          <td>(</td>
          <td class="paramtype">planar_line&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">planar_line&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; point&lt; T, 2 &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines wheter two planar lines intersect each other. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type for coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l1</td><td>first line</td></tr>
    <tr><td class="paramname">l2</td><td>second line</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the coordinates of the intersection point if it exists </dd></dl>

</div>
</div>
<a class="anchor" id="a90d3489c0c5415591e1e1092a8c8ad27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; msc::get_all_edge_lengths </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all edge lengths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>edge lengths in unspecified order </dd></dl>

</div>
</div>
<a class="anchor" id="a27d52b354738f4beb6d29b372710031c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a>, 5&gt;&amp; msc::all_algorithms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed835959c86eb037e762c3ff06655e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">algorithms&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9188d09cfe45cee611d916401b739689"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a93a867f812a195890b25dc49b0c14c9b">algorithms</a> msc::value_of_algorithms </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fb392dc67542ba306260e1524afa20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a>, 3&gt;&amp; msc::all_binnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a04c7a900d18cacd360f211a24e50b77f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">binnings&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cdc4553a9880ed4206ce10b23466c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a5396b55ae4ea5a0cf2e7add71dca29ed">binnings</a> msc::value_of_binnings </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67b6f20bcb66876e063d9d769b6ad89b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a>, 4&gt;&amp; msc::all_compressions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a0a0281a426c71a4921711b55f3b57326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">compressions&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e9020ff3e68668c2a15210ab61510d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a> msc::value_of_compressions </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb8bf95ccae2c40d79d81c7893dab028"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a>, 2&gt;&amp; msc::all_distributions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a78ed93ac534cdf71778774130d8e40ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">distributions&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2b1795ee21966de46cf71e572d5a457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#ae26ed6099a182e487884926c1a32e4f0">distributions</a> msc::value_of_distributions </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72357f313ae8745d242cf803ffe5df0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a>, 20&gt;&amp; msc::all_fileformats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a1f237c430b107b903b29246bc17bbb79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38ca3318fd8c30d7c78f9bc462f732e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> msc::value_of_fileformats </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84400a106d7d2053e2949f57ce3b84b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a>, 3&gt;&amp; msc::all_kernels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="ab9b5bacbf3b7b252e6207494b4cb4bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">kernels&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6efc23f4e42fed42d0037a8b17e16cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a196c75041f232c8f8c22d81fd90b8274">kernels</a> msc::value_of_kernels </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab409b5c3ca7507c789550e4389f9d741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a>, 4&gt;&amp; msc::all_projections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a5b2bfc9b325611412f30ddd0efd12c90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">projections&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad458616967f97fb27dddda6bc2c2be9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475">projections</a> msc::value_of_projections </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc40feb28d95d981cc79f3728a440b25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a>, 4&gt;&amp; msc::all_terminals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a1a98f8a24674b0a668f6672fc3d37c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">terminals&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a475788cc4928371f0dd3e19b255ce761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a9e4f85e669d8d8947ab2fafa95dd6598">terminals</a> msc::value_of_terminals </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5509cd4248ba252c6dbdd8eb10d72aed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::array&lt;<a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a>, 3&gt;&amp; msc::all_treatments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a constant reference to a statically allocated array of all declared enumerators. </p>
<dl class="section return"><dt>Returns</dt><dd>array with all declared enumerators </dd></dl>

</div>
</div>
<a class="anchor" id="a5af4048c07ba9f49a3e582cbf823ed8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::name </td>
          <td>(</td>
          <td class="paramtype">treatments&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the canonical name of an enumerator. </p>
<p>The returned name will consist of one or more lower-case words joined together with a dash, for example <code>beta</code> or <code>alpha-omega</code>. The character array the returned <code>std::string_view</code> refers to is statically allocated and guaranteed to be NUL terminated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>enumerator to get the name for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>canonical enumerator name</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the constant is not a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87ee6482b19a96c5b26bb6e4a5053ae8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20">treatments</a> msc::value_of_treatments </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the enumerator for a name. </p>
<p>The conversion is case-insensitive and ignores leading and trailing white-space. In addition to converting names, if <code>name</code> parses as a decimal integer (no leading signum allowed) then the enumerator with that numerical value is returned, if it is declared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name to get the enumeration constant for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>enumeration constant</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name does not refer to a declared enumerator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b379b7f3077336fef08bf586e9e279e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::operator== </td>
          <td>(</td>
          <td class="paramtype">const file &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const file &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <code>file</code>s for equality. </p>
<p>Two files are considered equal if and only if they both refer to the same terminal type, file name, file descriptor and compression. The "mode" is not considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>first file to compare</td></tr>
    <tr><td class="paramname">rhs</td><td>second file to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the two files refer to the same I/O file </dd></dl>

</div>
</div>
<a class="anchor" id="a1067d6c4cdeef219fa9ab99ab49ba94a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const file &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const file &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <code>file</code>s for inequality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>first file to compare</td></tr>
    <tr><td class="paramname">rhs</td><td>second file to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(lhs == rhs)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6f564a7bd01e10abef320189e02e7fd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::graph_fingerprint </td>
          <td>(</td>
          <td class="paramtype">const ogdf::Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fixed-length string that only depends on the given graph and is unlikely to collide with the ID returned for any other graph. </p>
<p>Note that isomorphic graphs with different labels will (almost certainly) not get the same ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to obtain an ID for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>almost unique ID for the graph </dd></dl>

</div>
</div>
<a class="anchor" id="aad3cfe66d267275c3278ca0884acbcf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::layout_fingerprint </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fixed-length string that only depends on the given layout and is unlikely to collide with the ID returned for any other layout. </p>
<p>Note that isomorphic graphs with different labels will (almost certainly) not get the same ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to obtain an ID for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>almost unique ID for the graph </dd></dl>

</div>
</div>
<a class="anchor" id="a0d195f549cd886ac8c92f8a1a15fc96a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double msc::binwidth_scott_normal_reference </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stdev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the suggested binwidth according to Scott's normal reference rule. </p>
<p>The behavior is undefined unless <code>n &gt; 0</code> and <code>stdev &gt; 0.0</code>.</p>
<p><a href="https://en.wikipedia.org/wiki/Histogram#Scott.27s_normal_reference_rule">https://en.wikipedia.org/wiki/Histogram#Scott.27s_normal_reference_rule</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>number of observed events</td></tr>
    <tr><td class="paramname">stdev</td><td>observed standard deviation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>recommended bin width </dd></dl>

</div>
</div>
<a class="anchor" id="aa32615ac5567a1bd2d3665f04ef03883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ogdf::Graph&gt; msc::import_graph </td>
          <td>(</td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a graph from a file in the specified format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>file to read from</td></tr>
    <tr><td class="paramname">format</td><td>graph file format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if no graph can be read from the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac22645b1acf63f42cc1ba99925a8c0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;ogdf::Graph&gt;, std::unique_ptr&lt;ogdf::GraphAttributes&gt; &gt; msc::import_layout </td>
          <td>(</td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a layout from a file in the specified format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>file to read from</td></tr>
    <tr><td class="paramname">format</td><td>layout file format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair with the graph and layout</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if no layout can be read from the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c50ae14cb97ff7d460f258de8501ec0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;ogdf::Graph&gt;, std::unique_ptr&lt;ogdf::GraphAttributes&gt; &gt; msc::import_layout_or_graph </td>
          <td>(</td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a layout from a file in the specified format if present; otherwise just the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>file to read from</td></tr>
    <tr><td class="paramname">format</td><td>layout file format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair with the graph and layout (the latter may be null)</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if no layout or graph can be read from the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2d0d14354924438f964fd69cad7c9eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::export_graph </td>
          <td>(</td>
          <td class="paramtype">const ogdf::Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a graph in a file using the default format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to store</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
    <tr><td class="paramname">format</td><td>graph file format</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the graph cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc38e195638cbf6f287daa84d1fe9f6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::export_layout </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">fileformats&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a layout in a file using the default format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to store</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
    <tr><td class="paramname">format</td><td>layout file format</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the layout cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac495fb8df270968823f59b5085382c19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;ogdf::Graph&gt; msc::load_graph </td>
          <td>(</td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a graph from a file in the internal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>file to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the graph</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if no graph can be read from the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d4cfae8e516c6d836d7f20f732208f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::unique_ptr&lt;ogdf::Graph&gt;, std::unique_ptr&lt;ogdf::GraphAttributes&gt; &gt; msc::load_layout </td>
          <td>(</td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a layout from a file in the internal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>file to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair with the graph and layout</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if no layout can be read from the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a356eece3ce6b4c07de3ef5931b28d207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::store_graph </td>
          <td>(</td>
          <td class="paramtype">const ogdf::Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a graph in a file using the internal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to store</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the graph cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9133c77fdaee8ce3154111d878fe6cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::store_layout </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a layout in a file using the internal format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to store</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the layout cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f982fe3da18449c8a00423b2960290c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::write_events </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stochastic_summary &amp;&#160;</td>
          <td class="paramname"><em>summary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes event data to a text file. </p>
<p>The format is such that it can be processed by Gnuplot and similar tools.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>event data to write</td></tr>
    <tr><td class="paramname">summary</td><td>stochastic summary of the event data</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the data cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a732420e2db87ca1137e97ca48594cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::write_frequencies </td>
          <td>(</td>
          <td class="paramtype">const histogram &amp;&#160;</td>
          <td class="paramname"><em>histo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes frequency data to a text file. </p>
<p>The format is such that it can be processed by Gnuplot and similar tools.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">histo</td><td>binned frequency data to write</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the data cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c7b4acb45b35b0af2118e96c3c4caa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::write_density </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stochastic_summary &amp;&#160;</td>
          <td class="paramname"><em>summary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes density data to a text file. </p>
<p>The format is such that it can be processed by Gnuplot and similar tools.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>array of (<em>x</em>, &rho;(<em>x</em>)) points describing the normalized density</td></tr>
    <tr><td class="paramname">summary</td><td>stochastic summary of the event data</td></tr>
    <tr><td class="paramname">dst</td><td>file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="namespacemsc.html#a2016583431e89758955af6974010aa20a42552b1f133f9f8eb406d4f306ea9fd1" title="throw an exception and give up on the computation ">std::exception</a></td><td>if the data cannot be written to the given file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b05f89182c1c4addf49379e65c14774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string_view msc::check_filename </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the given string can possibly be a sane file name. </p>
<p>This function rejects only the empty string and strings with leading or trailing white-space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file name to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>its argument</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the name was invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fd339df403daabedc79b18fea947d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msc::check_descriptor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the given integer can possibly be a sane file descriptor. </p>
<p>This function rejects only negative integers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descriptor</td><td>file descriptor to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>its argument</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the integer was invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a710bc5b0e7252708cd8787c6dabebf79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string_view, std::string_view&gt; msc::split_filename </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a file name into the actual file name and an optional compression specification. </p>
<p>The file name is split at the last instance of a <code>:</code> character. For example, <code>"STDIO:gzip"</code> will be split into <code>{"STDIO", "gzip"}</code> and <code>"C:\\\\Documents\\\\file.txt:none"</code> into <code>{"C:\\\\Documents\\\\file.txt", "none"}</code>.</p>
<p>No validation whatsoever on the compression specification is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file name to split</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of actual file name and compression specification </dd></dl>

</div>
</div>
<a class="anchor" id="afca3de98fe6236adcd1f88122ab756cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::is_nullio </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a file name shall be interpreted as no input or output output. </p>
<p>This function returns <code>true</code> for and only for the string <code>"NULL"</code> and the empty string. It does <em>not</em> return <code>true</code> for <code>"/dev/null"</code> or any integer. These file names should not be treated specially because they are not semantically equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file name to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the file name refers to no input or output </dd></dl>

</div>
</div>
<a class="anchor" id="adf3669c32fb45c6df193c2123dedd7f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::is_stdio </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a file name shall be interpreted as standard input or output. </p>
<p>This function returns <code>true</code> for and only for the strings <code>"STDIO"</code> and <code>"-"</code>. It does <em>not</em> return <code>true</code> for <code>"/dev/std*"</code> or integers that happen to correspond to the respective file descriptors. These file names should not be treated specially because they are not semantically equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file name to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the file name refers to standard input or output </dd></dl>

</div>
</div>
<a class="anchor" id="a52eebdf6d39a7e0b642f483d2c657dea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;int&gt; msc::is_fdno </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a file name shall be interpreted as an open file descriptor and if so, its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>file name to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the file descriptor, if any </dd></dl>

</div>
</div>
<a class="anchor" id="a88330234a8601370af6522eb3105dc64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2caf">compressions</a> msc::guess_compression </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to guess the compression applied to a file from its name. </p>
<p>The following suffixes will be understood.</p>
<table class="doxtable">
<tr>
<th>Suffix </th><th>Compression  </th></tr>
<tr>
<td><code>*.gz</code> </td><td><code><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa749cadba7b2ed8d4a2aaa91a9cb1896c" title="use gzip compression ">compressions::gzip</a></code>  </td></tr>
<tr>
<td><code>*.bz2</code> </td><td><code><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa03ce1ba314f367fdd09887fc8f60578b" title="use bzip2 compression ">compressions::bzip2</a></code>  </td></tr>
</table>
<p>If the <code>filename</code> does not match any of those extensions, <code><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa334c4a4c42fdb79d7ebc3e73b517e6f8" title="don&#39;t use any compression ">compressions::none</a></code> is returned. Under no circumstances will this function return <code><a class="el" href="namespacemsc.html#af083baa2f5eeb44f148fd49aa50b2cafa2bd9c0ed00116be1258e0cc66617d7c8" title="guess compression from the file name extension ">compressions::automatic</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>name of the file to guess about</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inferred compression </dd></dl>

</div>
</div>
<a class="anchor" id="a43fc48a5a43bf5a36168253637ad9b2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::report_io_error </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>message</em> = <code>&quot;I/O&#160;error&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Throws an exception to report an I/O error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>informal name of the file on which the I/O operation failed</td></tr>
    <tr><td class="paramname">message</td><td>description of the error that occurred</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4df49d1b22a7bceb2925f374911ea59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::prepare_stream </td>
          <td>(</td>
          <td class="paramtype">boost::iostreams::filtering_istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const input_file &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stacks together a chain of I/O devices and filters suitable for reading from the given source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>default-constructed input stream to set up</td></tr>
    <tr><td class="paramname">src</td><td>source to read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>informal name of the input file </dd></dl>

</div>
</div>
<a class="anchor" id="a9955cb0a44ee216397199bf3694e7882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::prepare_stream </td>
          <td>(</td>
          <td class="paramtype">boost::iostreams::filtering_ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stacks together a chain of I/O devices and filters suitable for writing to the given destination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>default-constructed output stream to set up</td></tr>
    <tr><td class="paramname">dst</td><td>destination to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>informal name of the output file </dd></dl>

</div>
</div>
<a class="anchor" id="a863e83e3c8856fa77cec9dbf905ad0cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename JsonT , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a> msc::make_json </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>optval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a JSON object of type <code>JsonT</code> if <code>optval</code> holds a value or else <code><a class="el" href="structmsc_1_1json__null.html" title="Represents a null value. ">json_null</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">JsonT</td><td>type of the JSON object to create if a value is available</td></tr>
    <tr><td class="paramname">T</td><td>type of the value to construct a JSON object from</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optval</td><td>optional value to construct the JSON object from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON object that either holds <code>JsonT{*optval}</code> or <code>null</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6d38085f9b7d9854c0772e2b4332f20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#a5dd98b85959d8bf574c6a2c4315baf6d">json_any</a> msc::make_json </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a JSON object of type <code><a class="el" href="structmsc_1_1json__text.html" title="Wrapper for a text value. ">json_text</a></code> if <code>text</code> is non-empty or else <code><a class="el" href="structmsc_1_1json__null.html" title="Represents a null value. ">json_null</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>possibly empty string to store in a JSON object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>JSON object that either holds <code><a class="el" href="structmsc_1_1json__text.html" title="Wrapper for a text value. ">json_text</a>{text}</code> or <code>null</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ae8e69b79a26d2eb707828d0f52fadf93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_null &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a <code>null</code> value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a6b4da93cd624d7222d7b736a9899276e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_text &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a text value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="aef5768ade330bae3bdd5199b20c1f15e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_bool &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a logical value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a3e1c4a3b02038ad540937ff832b9b24e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_real &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a real value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a9f4ee4acf69e739ab1f6ebc3cae84814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_size &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a size value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a0f2424562d76592a323046a12162239d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_diff &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a difference value as JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="af8520b167ebbba519a19f59d16d63e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_array &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a JSON array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a0893adbc22993d79c8d006c0caf90683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_object &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out a JSON object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a56a00d8ff4aa00222a3e97e6148f2982"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const json_any &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streams out any JSON value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">obj</td><td>value to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a0692ff075a812552883a04b307c388a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::print_meta </td>
          <td>(</td>
          <td class="paramtype">const json_object &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const output_file &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializes and writes the meta data in <code>info</code> to <code>dest</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>JSON object to serialize and write</td></tr>
    <tr><td class="paramname">dest</td><td>destination to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>if there was an error writing to the file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae251bcbbe6c7e47ec5a8c5a477cb118d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::normalize_layout </td>
          <td>(</td>
          <td class="paramtype">ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&ldquo;Normalizes&rdquo; a layout. </p>
<p>A normalized layout will be translated to have its center of gravity at the origin and scaled to have an average edge length of 100.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to be normalized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5534b682df2b4d77482d472d82889f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double msc::integrate_trapezoidal </td>
          <td>(</td>
          <td class="paramtype">FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the finite integral over a range given as (<em>x</em>, <em>f</em>(<em>x</em>)) points. </p>
<p>The data points do not have to equidistant. They have to be sorted with respect to the <em>x</em>-values, however. If the range contains less than two data-points, the behavior is undefined.</p>
<p>The complexity of this function is one pass over the range.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator that (if dereferenced) must be destructurable to a pair of floating-point values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing at the first data point</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing after the last data point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>approximate integral </dd></dl>

</div>
</div>
<a class="anchor" id="adcbcbbfc5888f01a804dbc60f2b732e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a> msc::get_coords </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceogdf.html#aab7fa381c31d9d41aaeec9046392b323">ogdf::node</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the coordinates of a vertex in a layout. </p>
<p>The behavior is undefined if the vertex does not belong th the layout's graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>vertex layout</td></tr>
    <tr><td class="paramname">v</td><td>vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>{attrs.x(v), attrs.y(v)}</code> </dd></dl>

</div>
</div>
<a class="anchor" id="accaef22cc4e968147d17da023cc9c050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a>, <a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a>&gt; msc::get_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pair containing the coordinates of the lower-left and upper-right corner of the layout's rectangular bounding box. </p>
<p>This function is a replacement for <code>ogdf::GraphAttributes::boundingBox()</code> which appears to do the wrong thing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to get the bounding box for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of coordinates </dd></dl>

</div>
</div>
<a class="anchor" id="a60c8aa7fef957df2655aea1e3e6f9298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemsc.html#ab7642ca88d0f3d1b6a8914ece4c0681e">msc::point2d</a> msc::get_bounding_box_size </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size (width and height) of the layout's rectangular bounding box. </p>
<p>This function is a replacement for <code>ogdf::GraphAttributes::boundingBox()</code> which appears to do the wrong thing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>layout to get the bounding box for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of dimensions </dd></dl>

</div>
</div>
<a class="anchor" id="a9082cf9f6a64d990da75cf2c55c7228b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="namespacemsc.html#a9a491ef1c186f808bbf89dec87e43f26">ogdf_node_array_2d</a>&lt;double&gt; &gt; msc::get_pairwise_shortest_paths </td>
          <td>(</td>
          <td class="paramtype">const ogdf::Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes all pairwise shortest paths in a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pairwise shortest path matrix </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f208364e157791d60dde4331b5dc60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Idx, typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto msc::get </td>
          <td>(</td>
          <td class="paramtype">point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; decltype(p.template get&lt;Idx&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a68ca48ccb3bf6eb20a199d346db04f25"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Idx, typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto msc::get </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> -&gt; decltype(p.template get&lt;Idx&gt;())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a36b87eaffbd92ad7f47d68f0cb6bf7e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool msc::operator== </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a90e58f19dfaf83b6829263fec30da229"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool msc::operator!= </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a07a6a8e32917ac33ae70a9fd3eedf301"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator+ </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a22ed5710dcdcb2533b8c89b2f466892f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator- </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a42ab051ea923d1ad094087717aad6908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator* </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a454b2057961b0c832dd52904f64e7866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator* </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a37b5baa39ab2ef0fb50cfeef2ab858bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator/ </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a413a9b671cb4b50eb4d9c6212e11c41e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::operator- </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab8064e3a72bcca49994e5836e2c899ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T msc::dot </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5297e55ece4fddb8412299444fb5bee9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T msc::normsq </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab87a7023d956ed3d82f11c8cdda49ced"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T msc::abs </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab08e1c32c30ce3dc73ae5b7c433059cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T msc::distance </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3da0839211dc8149c05283002b97aa7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 3&gt; msc::cross </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5a6d993f49dbc18241c95f8fa3554443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::make_point </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em> = <code>T{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a780efb5321157126f7a40784c4e319fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::make_unit_point </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5958d51332ca522ec5118d5de1e0db49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename EngineT , typename DistrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::make_random_point </td>
          <td>(</td>
          <td class="paramtype">EngineT &amp;&#160;</td>
          <td class="paramname"><em>rndeng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DistrT &amp;&#160;</td>
          <td class="paramname"><em>rnddst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af67a07b1481044feb8f3e222c398d7a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::make_invalid_point </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bc40962269d05b458cd8590cd81df3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::normalized </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5ed9b65ad03f1b0ede5b31e2de02d7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5409d6139f768967d62707b6ad5662d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; msc::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>istr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4f9101fffed55648652f9bcbf86ed79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EngineT , typename FwdIterT , typename PointT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;PointT, M&gt; msc::find_primary_axes </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EngineT &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname"><em>dimensions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a principal component analysis of an <em>N</em>-dimensional point cloud. </p>
<p>The algorithm uses Gram-Schmidt with power iteration and is therefore non-deterministic which is why this function accept a random engine as parameter.</p>
<p>The coordinates in the range <code>[first, last)</code> are modified during the process. On exit, the range will contain the coordinates with the first <code>M</code> principal components subtracted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EngineT</td><td>type of the random engine</td></tr>
    <tr><td class="paramname">FwdIterT</td><td>forward-iterator type of the iterator pair specifying the range of points</td></tr>
    <tr><td class="paramname">PointT</td><td>type of the <em>N</em>-dimensional point</td></tr>
    <tr><td class="paramname">T</td><td>floating-point type of the <em>N</em>-dimensional point's coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the <em>N</em>-dimensional points</td></tr>
    <tr><td class="paramname">M</td><td>number of principal components to compute (<code>M &lt;= N</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to the first point to consider</td></tr>
    <tr><td class="paramname">last</td><td>iterator past the last point to consider</td></tr>
    <tr><td class="paramname">engine</td><td>(pseudo) random engine to use</td></tr>
    <tr><td class="paramname">dimensions</td><td>constant to select the number of components that shall be determined</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of the first <code>M</code> principal component vectors (axes) </dd></dl>

</div>
</div>
<a class="anchor" id="adbf02ec9bdd17bc36aad02895fb3553a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EngineT , typename ContainerT , typename PointT  = typename ContainerT::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;PointT, M&gt; msc::find_primary_axes </td>
          <td>(</td>
          <td class="paramtype">ContainerT &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EngineT &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname"><em>dimensions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a principal component analysis of an <em>N</em>-dimensional point cloud. </p>
<p>This is a convenience overload for the function that takes a pair of iterators, accepting a container which supports <code>std::begin()</code> and <code>std::end()</code> instead.</p>
<p>The coordinates in the container are modified during the process. On exit, the container will contain the coordinates with the first <code>M</code> principal components subtracted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EngineT</td><td>type of the random engine</td></tr>
    <tr><td class="paramname">ContainerT</td><td>type of the container holding the points</td></tr>
    <tr><td class="paramname">PointT</td><td>type of the <em>N</em>-dimensional point</td></tr>
    <tr><td class="paramname">T</td><td>floating-point type of the <em>N</em>-dimensional point's coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the <em>N</em>-dimensional points</td></tr>
    <tr><td class="paramname">M</td><td>number of principal components to compute (<code>M &lt;= N</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>container holding points</td></tr>
    <tr><td class="paramname">engine</td><td>(pseudo) random engine to use</td></tr>
    <tr><td class="paramname">dimensions</td><td>constant to select the number of components that shall be determined</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of the first <code>M</code> principal component vectors (axes) </dd></dl>

</div>
</div>
<a class="anchor" id="a8cec2e31edb64ec889ce90cc39c9999a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EngineT , typename ContainerT , typename PointT  = typename ContainerT::value_type, typename T  = typename PointT::value_type, std::size_t N = std::tuple_size&lt;PointT&gt;::value, std::size_t M = N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;PointT, M&gt; msc::find_primary_axes_nondestructive </td>
          <td>(</td>
          <td class="paramtype">ContainerT&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EngineT &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::integral_constant&lt; std::size_t, M &gt;&#160;</td>
          <td class="paramname"><em>dimensions</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a principal component analysis of an <em>N</em>-dimensional point cloud. </p>
<p>This is a convenience overload for the function that takes a pair of iterators, accepting a container which supports <code>std::begin()</code> and <code>std::end()</code> instead. Furthermore, the container is passed by-value so the original container will not be modified. Instead, a copy will be made.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EngineT</td><td>type of the random engine</td></tr>
    <tr><td class="paramname">ContainerT</td><td>type of the container holding the points</td></tr>
    <tr><td class="paramname">PointT</td><td>type of the <em>N</em>-dimensional point</td></tr>
    <tr><td class="paramname">T</td><td>floating-point type of the <em>N</em>-dimensional point's coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the <em>N</em>-dimensional points</td></tr>
    <tr><td class="paramname">M</td><td>number of principal components to compute (<code>M &lt;= N</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>container holding points</td></tr>
    <tr><td class="paramname">engine</td><td>(pseudo) random engine to use</td></tr>
    <tr><td class="paramname">dimensions</td><td>constant to select the number of components that shall be determined</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of the first <code>M</code> principal component vectors (axes) </dd></dl>

</div>
</div>
<a class="anchor" id="a4cc4a22c5168cd7f22fd553936bf96d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;(N &gt; 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, N&gt; msc::project_onto_plane </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects a point in <em>N</em>-dimensional space onto a 2-dimensional plane in that space. </p>
<p>The projection plane is given by its (<em>N</em>-dimensional) normal vector and implicitly assumed to pass through the origin.</p>
<p>The behavior is undefined <code>normal</code> is not normalized to 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type of point coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the space</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>point to be projected</td></tr>
    <tr><td class="paramname">normal</td><td>surface normal of the projection plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a379163eb32afc091b8077c3de6363512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N, typename  = std::enable_if_t&lt;(N &gt;= 2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 2&gt; msc::transform2d </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 2-dimensional coordinates of a point on a 2-dimensional plane in an <em>N</em>-dimensional space with respect to two freely chosen unit vectors. </p>
<p>The projection plane is implicitly assumed to pass through the origin. The behavior is undefined if it is impossible for <code>e1,</code>e2<code>and</code>coords<code>to lie in such a plane or</code>e1<code>and</code>e2` are linearly dependant.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type of point coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the space</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>point on the plane</td></tr>
    <tr><td class="paramname">e1</td><td>first unit vector</td></tr>
    <tr><td class="paramname">e2</td><td>second unit vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2-dimensional coordinates of <code>coords</code> with respect to the coordinate system defined by <code>e1</code> and <code>e2</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a101f59c64ad99dc0e02263610a77f158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 2&gt; msc::isometric_projection </td>
          <td>(</td>
          <td class="paramtype">const point&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the 2-dimensional coordinates of a <em>N</em>-dimensional point's isometric projection. </p>
<dl class="section warning"><dt>Warning</dt><dd>The coordinate computation will always be performed in double precision and the result casted to <code>T</code> afterwards.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type of point coordinates</td></tr>
    <tr><td class="paramname">N</td><td>dimensionality of the space</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coords</td><td>point to be projected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2-dimensional coordinates on the drawing area </dd></dl>

</div>
</div>
<a class="anchor" id="a85286fb7512309a10e2ca676b1649649"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structmsc_1_1point.html">point</a>&lt;T, 2&gt; msc::axonometric_projection </td>
          <td>(</td>
          <td class="paramtype">projections&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">point&lt; T, 3 &gt;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 2-dimensional coordinates of a 3-dimensional point's projection. </p>
<p>The behavior is undefined if <code>type</code> is not a declared enumerator.</p>
<p>If <code>type == <a class="el" href="namespacemsc.html#aa7a30e3eb0cf1bdd3810114605f47475a21a0862152ed5785891fbdbd42a5062a" title="isometric projection (axonometric) ">projections::isometric</a></code>, this function is a more efficient version of <code>isometric_projection</code> for the special case of a 3-dimensional space.</p>
<dl class="section warning"><dt>Warning</dt><dd>The coordinate computation will always be performed in double precision and the result casted to <code>T</code> afterwards.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>floating-point type of point coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of projection</td></tr>
    <tr><td class="paramname">coords</td><td>point to be projected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>2-dimensional coordinates on the drawing area </dd></dl>

</div>
</div>
<a class="anchor" id="a8bb1a3f33794ed111525d9925af4978e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EngT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::seed_random_engine </td>
          <td>(</td>
          <td class="paramtype">EngT &amp;&#160;</td>
          <td class="paramname"><em>engine</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seeds any random number engine.</p>
<p>This process is deterministic if and only if the environment variable <code>MSC_RANDOM_SEED</code> is set. Setting this environment variable to the value returned by this function will cause subsequent calls to this function to have the exact same effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">engine</td><td>engine to seed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>effective random seed </dd></dl>

</div>
</div>
<a class="anchor" id="a9e272027bff484f23cc386d0f88b22c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EngineT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::random_hex_string </td>
          <td>(</td>
          <td class="paramtype">EngineT &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deterministically returns a string with the requestd number of random bytes encoded in hex. </p>
<p>The string will contain (from left to right) the <code>bytes</code> hex encoded values that are obtained by successive calls to <code>engine</code> and using the least significant 8 bits from each result. When <code>engine</code> is a default-constructed engine of type <code>std::mt19937</code>, the returned string is <code>5cf6ee792cdf05e1ba2b6325c41a5f10</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EngineT</td><td>pseudo-random number generator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">engine</td><td>pseudo-random number generator</td></tr>
    <tr><td class="paramname">bytes</td><td>number of random bytes (string will have twice as many characters)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pseudo-random hex string </dd></dl>

</div>
</div>
<a class="anchor" id="ad7acb0a3371054d63604f954304e44c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename PairT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type, typename TX  = typename std::tuple_element&lt;0, PairT&gt;::type, typename TY  = typename std::tuple_element&lt;1, PairT&gt;::type, typename T  = std::common_type_t&lt;TX, TY&gt;, typename  = std::enable_if_t&lt;std::tuple_size&lt;PairT&gt;::value == 2 and std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, 2&gt; msc::linear_regression </td>
          <td>(</td>
          <td class="paramtype">FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a simple linear regression through a data set given by a list of of unordered (<em>x</em>, <em>y</em>)-pairs. </p>
<p>All data points are given equal (unit) weight.</p>
<p>If the data set ist empty, (NaN, NaN) is returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator type</td></tr>
    <tr><td class="paramname">PairT</td><td>2-tuple-like type holding two floating-point values</td></tr>
    <tr><td class="paramname">TX</td><td>type of the <em>x</em> values</td></tr>
    <tr><td class="paramname">TY</td><td>type of the <em>y</em> values</td></tr>
    <tr><td class="paramname">T</td><td>type of the computed intercept and incline</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator to first data point</td></tr>
    <tr><td class="paramname">last</td><td>iterator after last data point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of intercept and incline </dd></dl>

</div>
</div>
<a class="anchor" id="a83452b5696744740276d46978784dca3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename PairT  = typename ContainerT::value_type, typename TX  = typename std::tuple_element&lt;0, PairT&gt;::type, typename TY  = typename std::tuple_element&lt;1, PairT&gt;::type, typename T  = std::common_type_t&lt;TX, TY&gt;, typename  = std::enable_if_t&lt;std::tuple_size&lt;PairT&gt;::value == 2 and std::is_floating_point_v&lt;T&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, 2&gt; msc::linear_regression </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a simple linear regression through a data set given by a list of of unordered (<em>x</em>, <em>y</em>)-pairs. </p>
<p>This is a convenience overload for the more general version taking a pair of iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ConatinerT</td><td>container type</td></tr>
    <tr><td class="paramname">PairT</td><td>2-tuple-like type holding two floating-point values</td></tr>
    <tr><td class="paramname">TX</td><td>type of the <em>x</em> values</td></tr>
    <tr><td class="paramname">TY</td><td>type of the <em>y</em> values</td></tr>
    <tr><td class="paramname">T</td><td>type of the computed intercept and incline</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container of data points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of intercept and incline </dd></dl>

</div>
</div>
<a class="anchor" id="aa3f5e1dbedebd6d1c3f21e722ef2318f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::set_resource_limits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets (soft) resource limits according to environment variables. </p>
<p>The environment variables <code>MSC_LIMIT_CORE</code>, <code>MSC_LIMIT_CPU</code>, <code>MSC_LIMIT_DATA</code>, <code>MSC_LIMIT_FSIZE</code>, <code>MSC_LIMIT_NOFILE</code>, <code>MSC_LIMIT_STACK</code> and <code>MSC_LIMIT_AS</code> will be treated as integers that specify the respective soft limit for the respective resource. See <code>getrlimit(3p)</code> for a discussion of the semantics of these limits.</p>
<p>If a variable is not set, the respective limit will not be touched and remain at the system's default or a previously set limit. If any of the variables is set to a value other than <code>NONE</code> but cannot be parsed as a non-negative decimal integer or overflows the applicable range, an exception will be thrown and this function will have no effect. If a variable is set to the special string <code>NONE</code>, the soft limit for that resource will be cleared (set to <code>RLIM_INFINITY</code>). Depending on the previous limit in effect, this might not be the same as not touching the limit (if the environment variable is not set at all).</p>
<p>Hard limits will not be touched in any case.</p>
<p>On non-POSIX systems, this function still parses the environment variables but always throws an exception and has no effect. Note that this means that the user's desire to limit a resource will not be silently ignored on some systems, which is considered a feature.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if any of the influential environment variables is set to an invalid value</td></tr>
    <tr><td class="paramname">std::system_error</td><td>if setting a resource limit fails (always thrown on on-POSIX systems unless a previous error occurs) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfb606606154effcd2389f1e9f5e8b2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;double, double&gt; &gt; msc::make_density </td>
          <td>(</td>
          <td class="paramtype">const KernelT &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the density of an event distribution over a regular grid. </p>
<p>This function returns a list of <code>points</code> pairs <code>(x, y)</code> sorted by <code>x</code> where <code>x</code> is evenly spaced and ranges from <code>minval</code> to <code>maxval</code> (both inclusive). The values of <code>y</code> are determined by evaluating the <code>kernel</code> function at <code>x</code>. If <code>normalize == true</code>, then the values of <code>y</code> are additionally normalized such that the trapeziodal integral over the range of points is 1 unless the function is zero everywhere in which case the result will be zero, too.</p>
<p>The behavior is undefined if the function is non-deterministic, non-steady or negative over the given interval.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KernelT</td><td>univariate callable <code>double -&gt; double</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel</td><td>function to evaluate</td></tr>
    <tr><td class="paramname">minval</td><td>lowest value to consider</td></tr>
    <tr><td class="paramname">maxval</td><td>highest value to consider</td></tr>
    <tr><td class="paramname">points</td><td>number of evaluation points</td></tr>
    <tr><td class="paramname">normalize</td><td>whether the result shall be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of points </dd></dl>

</div>
</div>
<a class="anchor" id="aafe3eeadf48373790babc0bf75964c24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KernelT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;double, double&gt; &gt; msc::make_density_adaptive </td>
          <td>(</td>
          <td class="paramtype">const KernelT &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the density of an event distribution over an adaptive grid. </p>
<p>This function returns a list of <code>points</code> pairs <code>(x, y)</code> sorted by <code>x</code> where <code>x</code> ranges from <code>minval</code> to <code>maxval</code> (both inclusive). The values of <code>y</code> are determined by evaluating the <code>kernel</code> function at <code>x</code>. Evaluation points are chosen adaptively such that they'll be more dense in regions where the function has a high curvature. If <code>normalize == true</code>, then the values of <code>y</code> are additionally normalized such that the trapeziodal integral over the range of points is 1 unless the function is zero everywhere in which case the result will be zero, too.</p>
<p>The behavior is undefined if the function is non-deterministic, non-steady or negative over the given interval.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KernelT</td><td>univariate callable <code>double -&gt; double</code></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel</td><td>function to evaluate</td></tr>
    <tr><td class="paramname">minval</td><td>lowest value to consider</td></tr>
    <tr><td class="paramname">maxval</td><td>highest value to consider</td></tr>
    <tr><td class="paramname">normalize</td><td>whether the result shall be normalized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of points </dd></dl>

</div>
</div>
<a class="anchor" id="a5c44db28cd5fc85d11746011e5144496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double msc::get_differential_entropy_of_pdf </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; double, double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>density</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the differential entropy of a probability density function. </p>
<p>Note that differential entropy is not a direct measure of information content (see also: <a href="https://en.wikipedia.org/wiki/Differential_entropy">https://en.wikipedia.org/wiki/Differential_entropy</a>).</p>
<p>The behavior is undefined if the density is not normalized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">density</td><td>pointwise probability density function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>entropy of density </dd></dl>

</div>
</div>
<a class="anchor" id="aa1bdd4404e380e7ad4217d117fb9f05c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;ValueT&gt;, std::pair&lt;ValueT, ValueT&gt; &gt; msc::min_max </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum and maximum from a non-empty range of values. </p>
<p>The behavior is undefined if <code>first == last</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator type designating the range of values</td></tr>
    <tr><td class="paramname">ValueT</td><td>arithmetic type of the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first value in the range</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing past the last value in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of minimum and maximum value (in that order) </dd></dl>

</div>
</div>
<a class="anchor" id="a71467552f971415fdb9bbd7e0456aade"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;ValueT&gt;, std::pair&lt;ValueT, ValueT&gt; &gt; msc::min_max </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum and maximum from a non-empty container of values. </p>
<p>The behavior is undefined if the container is empty.</p>
<p>This is a convenience overload for the version that takes a pair of iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type</td></tr>
    <tr><td class="paramname">ValueT</td><td>arithmetic type of the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container holding the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of minimum and maximum value (in that order) </dd></dl>

</div>
</div>
<a class="anchor" id="a66d39f8d7ad6922aafc1b4ee16d6288c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, std::pair&lt;ValueT, ValueT&gt; &gt; msc::mean_stdev </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arithmetic mean and standard deviation of a range of three or more values. </p>
<p>The behavior is undefined if <code>std::distance(first, last) &lt; 3</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator type designating the range of values</td></tr>
    <tr><td class="paramname">ValueT</td><td>arithmetic type of the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first value in the range</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing past the last value in the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arithmetic mean and standard deviation (in that order) </dd></dl>

</div>
</div>
<a class="anchor" id="a71e5c4ac0f5a5e5ef29eef621b27ddcd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, std::pair&lt;ValueT, ValueT&gt; &gt; msc::mean_stdev </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the arithmetic mean and standard deviation of a container of three or more values. </p>
<p>The behavior is undefined if <code>container.size() &lt; 3</code>.</p>
<p>This is a convenience overload for the version that takes a pair of iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type</td></tr>
    <tr><td class="paramname">ValueT</td><td>arithmetic type of the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container holding the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>arithmetic mean and standard deviation (in that order) </dd></dl>

</div>
</div>
<a class="anchor" id="a86da94841a90a0c17c849b21e847a645"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a>&gt; msc::get_stochastic_summary </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes numer of events, minumum, maximum, mean and RMS of a population given by a pair of forward iterators. </p>
<p>The range is iterated only once and each iterator is dereferenced only once, which is preferable if iterating is non-trivial.</p>
<p>If the range is empty, the behavior is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator type that can be dereferenced to a floating-point value</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>begin of the range</td></tr>
    <tr><td class="paramname">last</td><td>end of the range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic stochastic properties of the population </dd></dl>

</div>
</div>
<a class="anchor" id="ab6f03ca0575d184828b0b3a6e5fa21fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, <a class="el" href="structmsc_1_1stochastic__summary.html">stochastic_summary</a>&gt; msc::get_stochastic_summary </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes numer of events, minumum, maximum, mean and RMS of a population given by a container. </p>
<p>This is a not-so-useful convenience overload of the function that takes a pair of iterators.</p>
<p>If the range is empty, the behavior is undefined.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type holding floating-point values</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container of events</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basic stochastic properties of the population </dd></dl>

</div>
</div>
<a class="anchor" id="ade6c4cacf83079e04382c0a69abd389c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FwdIterT , typename ValueT  = typename std::iterator_traits&lt;FwdIterT&gt;::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, ValueT&gt; msc::entropy </td>
          <td>(</td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FwdIterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the discrete entropy of a range of frequencies. </p>
<p>The behavior is undefined unless the range is empty or all values are non-negative and sum up to 1.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FwdIterT</td><td>forward iterator type</td></tr>
    <tr><td class="paramname">ValueT</td><td>floating-point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>iterator pointing to the first frequency</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing past the last frequency</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>discrete entropy in bits </dd></dl>

</div>
</div>
<a class="anchor" id="a5e17e4f764294c6c76eef36469d95c6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename ValueT  = typename ContainerT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point_v&lt;ValueT&gt;, ValueT&gt; msc::entropy </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the discrete entropy of a container of frequencies. </p>
<p>The behavior is undefined unless the container is empty or all values are non-negative and sum up to 1.</p>
<p>This is a convenience overload for the function that takes a pair of iterators.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type</td></tr>
    <tr><td class="paramname">ValueT</td><td>floating-point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container of frequencies</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>discrete entropy in bits </dd></dl>

</div>
</div>
<a class="anchor" id="a495410bfc77a46070a2c41f4cf23b6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; msc::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const parabola_result &amp;&#160;</td>
          <td class="paramname"><em>pr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts an informal representation of <code>pr</code> into <code>ostr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ostr</td><td>stream to write to</td></tr>
    <tr><td class="paramname">pr</td><td>object to represent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <code>ostr</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aef2181a24ee8fbb7f9ee51b596a00535"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double msc::compute_stress </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>nodesep</em> = <code>default_node_distance</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the stress of a given layout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>normalized layout to compute the minmal stress for</td></tr>
    <tr><td class="paramname">nodesep</td><td>desired node separation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>stress for the specified node distance </dd></dl>

</div>
</div>
<a class="anchor" id="a8e96f24af01cdc374c1fd95bcc2544cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a> msc::compute_stress_fit_nodesep </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the adaptive stress of a given layout. </p>
<p>Stress is computed for the node distance that minimizes it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>normalized layout to compute the minmal stress for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fitted parabola (the <code>y0</code> member contains the stress value at node distance <code>x0</code>) </dd></dl>

</div>
</div>
<a class="anchor" id="a803a6cb8d58b82af222165df1e637720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmsc_1_1parabola__result.html">parabola_result</a> msc::compute_stress_fit_scale </td>
          <td>(</td>
          <td class="paramtype">const ogdf::GraphAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the adaptive stress of a given layout. </p>
<p>Stress is computed for a scaled layout that minimizes stress for the default node separation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attrs</td><td>normalized layout to compute the minmal stress for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fitted parabola (the <code>y0</code> member contains the stress value at scale <code>x0</code>) </dd></dl>

</div>
</div>
<a class="anchor" id="aa61ade32bc027d2d6270cbd2dd21e3cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::conjunction_v&lt;std::is_convertible&lt;Ts, std::string_view&gt;...&gt;, std::string&gt; msc::concat </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>parts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates zero or more string-like objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts...</td><td>types of the objects to concatenate (<code>char*</code>, <code>std::string</code>, <code>std::string_view</code>, ...)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parts</td><td>string-like objects to concatenate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>concatenated string </dd></dl>

</div>
</div>
<a class="anchor" id="ae0a0148100643bf0f12a1643dd892e31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::startswith </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether <code>prefix</code> is a prefix of <code>text</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to test</td></tr>
    <tr><td class="paramname">prefix</td><td>prefix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether <code>prefix</code> is a prefix of <code>text</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a8954a626ade1847488523f292b9b5314"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool msc::endswith </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether <code>suffix</code> is a suffix of <code>text</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to test</td></tr>
    <tr><td class="paramname">suffix</td><td>suffix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether <code>suffix</code> is a suffix of <code>text</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7b8dbfad6f34e0ea1f5146e3c1f91ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IterT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IterT msc::cyclic_next </td>
          <td>(</td>
          <td class="paramtype">const IterT&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterT&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IterT&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the next item in a sequence, wrapping over to the first at the end. </p>
<p>The behavior is undefined if <code>iter == last</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterT</td><td>iterator type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>iterator pointing to the current element</td></tr>
    <tr><td class="paramname">first</td><td>iterator pointing at the first element</td></tr>
    <tr><td class="paramname">last</td><td>iterator pointing after the last element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator pointing at the next element </dd></dl>

</div>
</div>
<a class="anchor" id="a46488066f524876bfa4d58e47866f08f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerT , typename T  = typename ContainerT::value_type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; msc::get_item </td>
          <td>(</td>
          <td class="paramtype">const ContainerT &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element at the specified index of a container if it exists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerT</td><td>container type (random access)</td></tr>
    <tr><td class="paramname">T</td><td>element type (can be specified differently if implicit conversion is desired)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>container to get element from</td></tr>
    <tr><td class="paramname">index</td><td>index of element to get</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element at index or nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a7cf446f1e4a9e8b5b38c6adfe1a3bfd8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T msc::get_same </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a non-empty list of equal values, returns the first value. </p>
<p>The behavior is undefined if the sequence is empty or contains values that do not compare equal to its first element.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the items</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>non-empty sequence of equal values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>items.front()</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a93d65d9e29775a99128adce17964695d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetT , typename SourceT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;TargetT&gt; msc::optional_cast </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; SourceT &gt;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the <code>src</code> contains a value (of type <code>SourceT</code>), it is <code>static_cast</code> to <code>TargetT</code> and returned as a new optional value; otherwise, an empty optional is returned. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TargetT</td><td>type of the optional value to cast from</td></tr>
    <tr><td class="paramname">SourceT</td><td>type of the optional value to cast to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>optional value to cast</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>casted optional value </dd></dl>

</div>
</div>
<a class="anchor" id="a048ccc8eccb210f2cfae085d3f311174"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::shared_ptr&lt;T1&gt;, std::shared_ptr&lt;T2&gt; &gt; msc::share_pair </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::unique_ptr&lt; T1 &gt;, std::unique_ptr&lt; T2 &gt;&gt;&#160;</td>
          <td class="paramname"><em>duo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a pair of shared pointers from a pair of unique pointers via the respective conversion constructor. </p>
<p>This function cannot be <code>noexcept</code> because in the unlikely event that the memory allocation for the shared pointer control block should fail, a <code>std::bad_alloc</code> will be thrown.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the first managed object</td></tr>
    <tr><td class="paramname">T2</td><td>type of the second managed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">duo</td><td>pair of unique objects</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pair of shared objects </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5a23daf06e36ca12201ac66c3c5d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string msc::normalize_constant_name </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a textual constant name (as it might appear in JSON) in order to prepare it for being converted to a C++ enumerator constant. </p>
<p>Normalization consists of trimming white-space, converting all characters to lower-case and replacing underscores with dashes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>constant name to normalize</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>normalized constant name </dd></dl>

</div>
</div>
<a class="anchor" id="ab8978d9102ba0043fc2d74ab8987dcfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::reject_invalid_enumeration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports an error due to an invalid enumerator constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>offending numeric value of the enumeration constant</td></tr>
    <tr><td class="paramname">name</td><td>informal name for the enumeration type</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>that's its purpose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13e7e9c0b7dec60a1b69c6e0d603cc3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EnumT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_enum_v&lt;EnumT&gt; &gt; msc::reject_invalid_enumeration </td>
          <td>(</td>
          <td class="paramtype">const EnumT&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper for <code>reject_invalid_enumeration</code> when the constant is already of the enumeration's type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EnumT</td><td>type of the enum</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>offending enumeration constant</td></tr>
    <tr><td class="paramname">name</td><td>informal name for the enumeration type</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>that's its purpose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7d3a6c9420589b0a6b395c789d1323f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msc::reject_invalid_enumeration </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports an error due to an invalid enumerator name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>offending enumeration name</td></tr>
    <tr><td class="paramname">name</td><td>informal name for the enumeration type</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>that's its purpose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab84a5f91060ba6302c7a24fe94a722f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;int&gt; msc::parse_decimal_number </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests whether a string parses as decimal number and if so returns its value. </p>
<p>This function will return nothing if the number looks like a decimal integer (matches <code>\d+</code>) but exceeds <code>INT_MAX</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>text to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>just the numeric value or else nothing </dd></dl>

</div>
</div>
<a class="anchor" id="a658ee284c6eecb26a46aa760523a7efb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt; msc::square </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squares a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">arithmetic</td><td>type of the argument and result</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value to square</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>squared value </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ad73f1162b3a285e72f31c41075f49f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacemsc.html#ad45abf669ad17a61f470330d16a9cbcb">fileformats</a> msc::internal_file_format</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Preferred graph and layout file format. </p>

</div>
</div>
<a class="anchor" id="a9c9ae02864f293bda20ee14ba2b72e96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto msc::default_node_distance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Average edge length in normalized layouts. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
